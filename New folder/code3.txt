#data_structures.py
import json

class MinHeap:
    def __init__(self):
        self.heap = []

    def push(self, item):
        self.heap.append(item)
        self._heapify_up(len(self.heap) - 1)

    def pop(self):
        if len(self.heap) == 0:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()
        root = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)
        return root

    def _heapify_up(self, index):
        parent = (index - 1) // 2
        if index > 0 and self.heap[index] < self.heap[parent]:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            self._heapify_up(parent)

    def _heapify_down(self, index):
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        if left < len(self.heap) and self.heap[left] < self.heap[smallest]:
            smallest = left
        if right < len(self.heap) and self.heap[right] < self.heap[smallest]:
            smallest = right
        if smallest != index:
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
            self._heapify_down(smallest)

    def peek(self):
        if self.heap:
            return self.heap[0]
        return None
    def is_empty(self):
        return len(self.heap) == 0

    def size(self):
        return len(self.heap)



class Graph:
    def __init__(self):
        self.nodes = {}

    def add_node(self, location):
        if location not in self.nodes:
            self.nodes[location] = {}

    def add_edge(self, start, end, distance):
        if start in self.nodes and end in self.nodes:
            self.nodes[start][end] = distance
            self.nodes[end][start] = distance  # Since it's an undirected graph

    def get_neighbors(self, node):
        return self.nodes.get(node, {})

    def dijkstra(self, start):
        """
        Implementation of Dijkstra's shortest path algorithm using MinHeap.
        
        Args:
            start: Starting node
            
        Returns:
            Dictionary of shortest distances to all nodes from start node
            Dictionary of previous nodes in the shortest path
        """
        # Initialize distances with infinity for all nodes except start
        distances = {node: float('infinity') for node in self.nodes}
        distances[start] = 0
        
        # Dictionary to store the previous node in shortest path
        previous = {node: None for node in self.nodes}
        
        # Create min heap for storing vertices to visit
        pq = MinHeap()
        pq.push((0, start))  # (distance, node)
        
        # Set to keep track of visited nodes
        visited = set()
        
        while not pq.is_empty():
            # Get the node with minimum distance
            current_distance, current_node = pq.pop()
            
            # If we've already processed this node, skip it
            if current_node in visited:
                continue
                
            # Mark node as visited
            visited.add(current_node)
            
            # If current distance is greater than known distance, skip
            if current_distance > distances[current_node]:
                continue
            
            # Check all neighbors of current node
            for neighbor, weight in self.nodes[current_node].items():
                # Skip if neighbor is already visited
                if neighbor in visited:
                    continue
                    
                # Calculate tentative distance to neighbor
                distance = current_distance + weight
                
                # If we found a shorter path, update it
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_node
                    pq.push((distance, neighbor))
        
        return distances, previous

    def get_shortest_path(self, start, end):
        """
        Gets the shortest path between start and end nodes.
        
        Args:
            start: Starting node
            end: Ending node
            
        Returns:
            tuple: (path_distance, path_nodes)
            where path_distance is the total distance
            and path_nodes is a list of nodes in the path
        """
        # Get shortest distances and previous nodes
        distances, previous = self.dijkstra(start)
        
        if distances[end] == float('infinity'):
            return None, None  # No path exists
            
        # Reconstruct the path
        path = []
        current = end
        
        while current is not None:
            path.append(current)
            current = previous[current]
            
        # Reverse path to get it from start to end
        path.reverse()
        
        return distances[end], path

    def get_all_paths(self, start):
        """
        Gets all shortest paths from start node to all other nodes.
        
        Args:
            start: Starting node
            
        Returns:
            Dictionary with end nodes as keys and (distance, path) tuples as values
        """
        distances, previous = self.dijkstra(start)
        paths = {}
        
        for end in self.nodes:
            if end == start:
                paths[end] = (0, [start])
                continue
                
            if distances[end] == float('infinity'):
                paths[end] = (None, None)
                continue
                
            # Reconstruct path
            path = []
            current = end
            while current is not None:
                path.append(current)
                current = previous[current]
            path.reverse()
            
            paths[end] = (distances[end], path)
            
        return paths

class DoublyLinkedList:
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None
            self.prev = None

    def __init__(self):
        self.head = None
        self.tail = None

    def to_list(self):
        """Convert the linked list into a list."""
        result = []
        current = self.head
        while current:
            result.append(current.data)  # Assuming each node has a 'data' attribute
            current = current.next
        return result

    @classmethod
    def from_list(cls, data_list):
        """Reconstruct the linked list from a list."""
        new_list = cls()
        for item in data_list:
            new_list.append(item)  # Assuming an `append` method exists
        return new_list

    def append(self, data):
        new_node = self.Node(data)
        if not self.head:
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def traverse_forward(self):
        current = self.head
        while current:
            print(current.data)
            current = current.next

    def traverse_backward(self):
        current = self.tail
        while current:
            print(current.data)
            current = current.prev

    def delete(self, data):
        current = self.head
        while current:
            if current.data == data:
                if current.prev:
                    current.prev.next = current.next
                if current.next:
                    current.next.prev = current.prev
                if current == self.head:
                    self.head = current.next
                if current == self.tail:
                    self.tail = current.prev
                return
            current = current.next

class HashTable:
    def __init__(self, size=10):  # Initialize with a default size
        self.table = {}  # Use a dictionary to store key-value pairs

    def hash_function(self, key):
        # Simple hash function (you can implement more sophisticated ones)
        hash_value = hash(key) % len(self.table) if self.table else 0
        return hash_value
    
    def save_to_file(self, filename):
        table_data = {}
        for bucket in self.table.values():
            if bucket:
                for key, value in bucket:
                    # Serialize DoublyLinkedList objects
                    serializable_value = value.copy()  # Copy the dictionary
                    if isinstance(value.get('ride_history'), DoublyLinkedList):
                        serializable_value['ride_history'] = value['ride_history'].to_list()
                    table_data[key] = serializable_value
        try:
            with open(filename, 'w') as f:
                json.dump(table_data, f, indent=4)
            print(f"Data successfully saved to {filename}")
        except Exception as e:
            print(f"Error saving to file {filename}: {e}")

    def load_from_file(self, filename):
        try:
            with open(filename, 'r') as f:
                data = json.load(f)
                print("Loaded users:", self.users)  # Debug statement
                for key, value in data.items():
                    # Deserialize DoublyLinkedList objects
                    if 'ride_history' in value:
                        value['ride_history'] = DoublyLinkedList.from_list(value['ride_history'])
                    self.insert(key, value)
            print(f"Data successfully loaded from {filename}")
        except FileNotFoundError:
            print(f"{filename} not found. Starting with an empty table.")
        except Exception as e:
            print(f"Error loading file {filename}: {e}")



    def insert(self, key, value):
        index = self.hash_function(key)
        if index not in self.table:
            self.table[index] = []
        self.table[index].append((key, value))  # Handle collisions by storing in list

    def get(self, key):
        index = self.hash_function(key)
        if index in self.table:
            for k, v in self.table[index]:
                if k == key:
                    return v
        return None

    def delete(self, key):
        index = self.hash_function(key)
        if index in self.table:
            for i, (k, v) in enumerate(self.table[index]):
                if k == key:
                    del self.table[index][i]
                    break

    def values(self):
        # Flatten the table and return all values
        return [value for bucket in self.table.values() for key, value in bucket]

    def items(self):
        # Flatten the table and return all key-value pairs
        return [(key, value) for bucket in self.table.values() for key, value in bucket]

class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, item):
        self.queue.append(item)

    def dequeue(self):
        if self.queue:
            return self.queue.pop(0)
        return None

    def is_empty(self):
        return len(self.queue) == 0

    def peek(self):
        if self.queue:
            return self.queue[0]
        return None

class PriorityQueue(MinHeap):
    def __init__(self):
        super().__init__()

    def push(self, priority, item):
        super().push((priority, item))

    def pop(self):
        return super().pop()[1] if self.heap else None

    def peek(self):
        return self.heap[0][1] if self.heap else None

class AVLTree:
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.value = value
            self.height = 1
            self.left = None
            self.right = None

    def __init__(self):
        self.root = None

    # Implement AVL Tree methods (insert, delete, rotate, balance) as needed

# Additional data structures can be added here if necessary for the project requirements.

#driver_management.py
from data_structures import HashTable, DoublyLinkedList
import uuid

# driver_management.py
class DriverManagement:
    def __init__(self):
        self.drivers = HashTable()
        self.active_drivers = HashTable()  # Currently available drivers
        self.drivers.load_from_file('drivers_data.json')
    def register_driver(self, name, email, phone, password, vehicle_type, license_number):
        driver_id = str(uuid.uuid4())
        driver_data = {
            'id': driver_id,
            'name': name,
            'email': email,
            'phone': phone,
            'password': password,  # Should be hashed in real system
            'vehicle_type': vehicle_type,
            'license_number': license_number,
            'rating': 0.0,
            'total_ratings': 0,
            'current_location': None,
            'active_ride': None,
            'ride_history': DoublyLinkedList()
        }
        
        if self.get_driver_by_email(email):
            return False, "Email already registered"
            
        self.drivers.insert(driver_id, driver_data)
        # Save to file immediately
        self.drivers.save_to_file('drivers_data.json')
        return True, driver_id
            
    def login_driver(self, email, password):
        print("Debug: Drivers table contents:", self.drivers.table)  # Debug statement
        for bucket in self.drivers.table.values():
            print("Debug: Current bucket:", bucket)  # Debug statement
            if bucket:  # Ensure the bucket is not empty
                for driver_id, driver_data in bucket:  # Iterate through the list of key-value pairs
                    print("Debug: Checking driver_data:", driver_data)  # Debug statement
                    if isinstance(driver_data, dict) and driver_data.get('email') == email and driver_data.get('password') == password:
                        return True, driver_id
        return False, "Invalid credentials"



        
    def update_driver_location(self, driver_id, location):
        driver_data = self.drivers.get(driver_id)
        if driver_data:
            driver_data['current_location'] = location
            self.drivers.insert(driver_id, driver_data)
            return True
        return False
        
    def set_driver_availability(self, driver_id, available):
        if available:
            driver_data = self.drivers.get(driver_id)
            if driver_data and not driver_data['active_ride']:
                self.active_drivers.insert(driver_id, driver_data)
                return True
        else:
            self.active_drivers.delete(driver_id)
            return True
        return False
    
    def get_driver_by_email(self, email):
    # Check if any driver has the given email
        for driver_data_list in self.drivers.table:
            if driver_data_list:  # Ensure there is data in this bucket
                for _, driver in driver_data_list:
                    if driver['email'] == email:
                        return driver
        return None


    def get_available_drivers(self):
        return self.active_drivers.table.values()

    def get_driver_by_id(self, driver_id):
        return self.drivers.get(driver_id)

# emergency_handler.py
from data_structures import PriorityQueue
import time
import uuid

class EmergencyHandler:
    def __init__(self, ride_request, location_service, driver_management):
        self.ride_request = ride_request
        self.location_service = location_service
        self.driver_mgmt = driver_management
        self.emergency_requests = PriorityQueue()

    def add_emergency_request(self, user_id, pickup_location, dropoff_location):
        """
        Adds an emergency ride request to the queue with the highest priority.
        Simulates forwarding the request to a 911-like service.
        """
        request = {
            'id': str(uuid.uuid4()),
            'user_id': user_id,
            'pickup_location': pickup_location,
            'dropoff_location': dropoff_location,
            'timestamp': time.time(),
        }
        print(f"Emergency request forwarded to 911 service: {request}")
        self.emergency_requests.push(1, request)  # Priority 1 for emergency requests
        return True, request['id']

    def dispatch_emergency_ride(self):
        """
        Processes the emergency ride queue and dispatches the nearest available emergency vehicle.
        Simulates fetching emergency vehicle location data from a 911-like service.
        """
        if self.emergency_requests.is_empty():
            return False, "No emergency requests in the queue."

        request = self.emergency_requests.pop()
        # Simulate receiving nearest vehicle location from 911 service
        print(f"Fetching nearest emergency vehicle for request: {request['id']}")
        driver = self._find_nearest_driver(request['pickup_location'])

        if driver:
            ride_id = self.ride_request._assign_ride(request, driver['id'])
            return True, f"Emergency ride dispatched. Ride ID: {ride_id}"

        return False, "No available emergency vehicles for dispatch."

    def _find_nearest_driver(self, pickup_location):
        """
        Finds the nearest available driver for the given pickup location.
        Simulates receiving driver data from 911.
        """
        available_drivers = self.driver_mgmt.get_available_drivers()
        print("Available drivers fetched from 911 system.")
        nearest_driver = None
        min_distance = float('inf')

        for driver in available_drivers:
            if driver['current_location']:
                distance = self.location_service.get_shortest_path_distance(pickup_location, driver['current_location'])
                if distance < min_distance:
                    min_distance = distance
                    nearest_driver = driver

        return nearest_driver


# location_service.py
from data_structures import Graph
from map_data import IslamabadMap
from map_data import LOCATIONS  # If you need LOCATIONS to get coordinates, etc.

class LocationService:
    def __init__(self, map_data):
        self.graph = Graph()
        self._initialize_map(map_data)

    def _initialize_map(self, map_data):
        """
        Initializes the graph with locations and distances from the map data.
        """
        # Use map_data's method to get all locations
        locations = map_data.get_all_locations()  # This method returns a list of locations
        for location in locations:
            self.graph.add_node(location)

        # Use the global DISTANCES constant
        from map_data import DISTANCES  # Import DISTANCES explicitly if it's not globally available
        for (start, end), distance in DISTANCES.items():  # Now we use DISTANCES directly
            self.graph.add_edge(start, end, distance)

    def get_shortest_path(self, start, end):
        # Implement the method to get the shortest path
        pass

    def get_nearby_locations(self, location, max_distance):
        """
        Gets all locations within a specified distance from the given location.
        """
        distances, _ = self.graph.dijkstra(location)
        return [loc for loc, dist in distances.items() if dist <= max_distance]

    def get_distance_between(self, start, end):
        """
        Returns the direct distance between two connected locations, if available.
        """
        return self.graph.nodes.get(start, {}).get(end, None)

    def is_valid_location(self, location):
        """
        Checks if a location exists in the map.
        """
        return location in self.graph.nodes

#map_data.py
from data_structures import Graph

# Dictionary of locations with their coordinates (x, y)
LOCATIONS = {
    # Sectors
    'F-6 Markaz': (0, 0),
    'F-7 Markaz': (2, 1),
    'G-9 Markaz': (-2, 3),
    'I-8 Markaz': (-4, 5),
    'E-11 Markaz': (-3, -2),
    'F-10 Markaz': (1, 3),
    'G-11 Markaz': (-1, 4),
    'F-17': (5, 7),
    'E-11': (-3, -3),
    'G-10': (0, 4),
    'D-12': (-5, -1),
    'F-11': (2, 4),
    'G-6': (-1, 1),
    
    # Universities
    'IIUI': (-6, 6),
    'Air University': (3, 5),
    'FAST University': (1, 2),
    'COMSATS': (4, 3),
    'NUST': (-2, 6),
    
    # Landmarks
    'Faisal Mosque': (0, 5),
    'Shakarparian': (3, -1),
    'Pakistan Monument': (2, -2),
    'Daman-e-Koh': (1, 6),
    'Centaurus Mall': (2, 0),
    'Serena Hotel': (1, 1)
}

# Dictionary of direct distances between connected locations
DISTANCES = {
    # Major connections between sectors
    ('F-6 Markaz', 'F-7 Markaz'): 3,
    ('F-7 Markaz', 'F-10 Markaz'): 4,
    ('F-10 Markaz', 'F-11'): 2,
    ('G-9 Markaz', 'G-10'): 2,
    ('G-10', 'G-11 Markaz'): 3,
    ('E-11 Markaz', 'E-11'): 1,
    ('I-8 Markaz', 'G-9 Markaz'): 5,
    
    # Connections to universities
    ('F-7 Markaz', 'FAST University'): 3,
    ('G-11 Markaz', 'NUST'): 4,
    ('F-10 Markaz', 'Air University'): 4,
    ('G-9 Markaz', 'COMSATS'): 6,
    ('E-11', 'IIUI'): 8,
    
    # Connections to landmarks
    ('F-7 Markaz', 'Centaurus Mall'): 2,
    ('F-6 Markaz', 'Serena Hotel'): 2,
    ('G-10', 'Faisal Mosque'): 3,
    ('F-11', 'Daman-e-Koh'): 4,
    ('F-7 Markaz', 'Pakistan Monument'): 4,
    ('F-6 Markaz', 'Shakarparian'): 5,
    
    # Additional strategic connections
    ('G-6', 'F-6 Markaz'): 2,
    ('G-6', 'G-9 Markaz'): 4,
    ('F-10 Markaz', 'G-10'): 2,
    ('F-11', 'E-11'): 5,
    ('D-12', 'E-11'): 3,
    ('F-17', 'Air University'): 4
}

class IslamabadMap:
    def __init__(self):
        self.graph = Graph()
        self._initialize_map()
    
    def _initialize_map(self):
        # Add all locations as nodes
        for location in LOCATIONS:
            self.graph.add_node(location)
        
        # Add all connections with distances
        # Add both directions since it's an undirected graph
        for (start, end), distance in DISTANCES.items():
            self.graph.add_edge(start, end, distance)
    
    def get_location_coordinates(self, location):
        """Get the coordinates of a specific location."""
        return LOCATIONS.get(location)
    
    def get_direct_distance(self, start, end):
        """Get the direct distance between two locations if they're directly connected."""
        return DISTANCES.get((start, end)) or DISTANCES.get((end, start))
    
    def get_shortest_path_distance(self, start, end):
        """Calculate the shortest path distance between any two locations."""
        if start not in LOCATIONS or end not in LOCATIONS:
            return None
        distances = self.graph.dijkstra(start)
        return distances[end]
    
    def get_nearby_locations(self, location, max_distance):
        """Get all locations within a specified distance of a given location."""
        if location not in LOCATIONS:
            return []
        distances = self.graph.dijkstra(location)
        return [loc for loc, dist in distances.items() if 0 < dist <= max_distance]
    
    def get_all_locations(self):
        """Return a list of all locations in the map."""
        return list(LOCATIONS.keys())
    
    def get_location_type(self, location):
        """Return the type of location (Sector, University, or Landmark)."""
        if location not in LOCATIONS:
            return None
        if 'University' in location or 'NUST' in location or 'IIUI' in location or 'COMSATS' in location:
            return 'University'
        if any(sector in location for sector in ['F-', 'G-', 'I-', 'E-', 'D-']):
            return 'Sector'
        return 'Landmark'

# Helper functions for the map
def is_valid_location(location):
    """Check if a location exists in the map."""
    return location in LOCATIONS

def get_distance_matrix():
    """Generate a complete distance matrix between all locations."""
    map_instance = IslamabadMap()
    locations = list(LOCATIONS.keys())
    matrix = {}
    
    for start in locations:
        matrix[start] = {}
        distances = map_instance.graph.dijkstra(start)
        for end in locations:
            matrix[start][end] = distances[end]
    
    return matrix
#map_visualization.py
import networkx as nx
import matplotlib.pyplot as plt
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))


def visualize_map(location_service):
    G = nx.Graph()
    for node in location_service.graph.nodes:
        G.add_node(node)
    for start, neighbors in location_service.graph.nodes.items():
        for end, distance in neighbors.items():
            G.add_edge(start, end, weight=distance)

    pos = nx.spring_layout(G)
    plt.figure(figsize=(10, 8))
    plt.gca().set_facecolor('black')

    nx.draw(
        G, pos,
        with_labels=True,
        node_color='lightgrey',
        edge_color='red',
        font_color='white',
        node_size=2000,
        font_size=10
    )

    labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_color='white')

    plt.title("Islamabad Ride-Hailing Map", color='white', fontsize=14)
    plt.show()

def visualize_ride_path(location_service, start, end):
    distance, path = location_service.graph.get_shortest_path(start, end)
    if path:
        G = nx.Graph()
        for node in location_service.graph.nodes:
            G.add_node(node)
        for start_node, neighbors in location_service.graph.nodes.items():
            for end_node, distance in neighbors.items():
                G.add_edge(start_node, end_node, weight=distance)

        pos = nx.spring_layout(G)
        nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=2000, font_size=10)

        path_edges = [(path[i], path[i + 1]) for i in range(len(path) - 1)]
        nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='red', width=2)

        labels = nx.get_edge_attributes(G, 'weight')
        nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

        plt.title(f"Ride Path from {start} to {end} (Distance: {distance})")
        plt.show()
    else:
        print("No path found between the selected locations.")
#polling.py
import os
import time
import sys
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

def poll_file(filename, hash_table, interval=5):
    last_modified = None
    while True:
        try:
            current_modified = os.path.getmtime(filename)
            if last_modified is None or current_modified > last_modified:
                print(f"{filename} has been updated. Reloading...")
                hash_table.load_from_file(filename)
                last_modified = current_modified
        except FileNotFoundError:
            print(f"{filename} not found. Skipping...")
        time.sleep(interval)
# pricing.py
class Pricing:
    def __init__(self, base_rate=10, per_km_rate=5, rideshare_discount=0.2, surge_multiplier=1.0):
        self.base_rate = base_rate
        self.per_km_rate = per_km_rate
        self.rideshare_discount = rideshare_discount
        self.surge_multiplier = surge_multiplier

    def calculate_fare(self, distance, is_rideshare=False, is_peak_time=False):
        """
        Calculates the fare for a given distance, with options for ridesharing and peak time pricing.
        """
        fare = self.base_rate + (distance * self.per_km_rate)
        if is_rideshare:
            fare *= (1 - self.rideshare_discount)
        if is_peak_time:
            fare *= self.surge_multiplier
        return round(fare, 2)

    def split_fare(self, total_fare, num_passengers):
        """
        Splits the fare among rideshare participants.
        """
        if num_passengers <= 0:
            return total_fare
        return round(total_fare / num_passengers, 2)# rating_system.py
class RatingSystem:
    def __init__(self, driver_management):
        self.driver_mgmt = driver_management
        
    def rate_driver(self, driver_id, rating):
        if rating < 1 or rating > 5:
            return False, "Rating must be between 1 and 5"
            
        driver = self.driver_mgmt.get_driver_by_id(driver_id)
        if not driver:
            return False, "Driver not found"
            
        # Update driver's rating
        total_ratings = driver['total_ratings']
        current_rating = driver['rating']
        
        new_total = total_ratings + 1
        new_rating = ((current_rating * total_ratings) + rating) / new_total
        
        driver['rating'] = round(new_rating, 2)
        driver['total_ratings'] = new_total
        
        self.driver_mgmt.drivers.insert(driver_id, driver)
        return True, driver['rating']
        
    def get_driver_rating(self, driver_id):
        driver = self.driver_mgmt.get_driver_by_id(driver_id)
        if driver:
            return True, {
                'rating': driver['rating'],
                'total_ratings': driver['total_ratings']
            }
        return False, "Driver not found"

# ride_history.py
from data_structures import DoublyLinkedList

class RideHistory:
    def __init__(self):
        self.ride_history = DoublyLinkedList()

    def add_ride(self, ride_data):
        """
        Adds a ride record to the user's ride history.
        """
        self.ride_history.append(ride_data)

    def get_ride_history(self):
        """
        Returns the list of all past rides in chronological order.
        """
        history = []
        current = self.ride_history.head
        while current:
            history.append(current.data)
            current = current.next
        return history
#ride_request.py
from data_structures import PriorityQueue, Queue, HashTable
import time
import uuid

class RideRequest:
    def __init__(self, user_management, driver_management):
        self.user_mgmt = user_management
        self.driver_mgmt = driver_management
        self.normal_requests = Queue()
        self.emergency_requests = PriorityQueue()
        self.active_rides = HashTable()
        
    def request_ride(self, user_id, pickup_location, dropoff_location, is_emergency=False):
        user = self.user_mgmt.get_user_by_id(user_id)
        if not user or user['active_ride']:
            return False, "Invalid user or user already has active ride"
            
        request = {
            'id': str(uuid.uuid4()),
            'user_id': user_id,
            'pickup_location': pickup_location,
            'dropoff_location': dropoff_location,
            'status': 'pending',
            'timestamp': time.time()
        }
        
        if is_emergency:
            self.emergency_requests.push(1, request)  # Priority 1 for emergency
        else:
            self.normal_requests.enqueue(request)
            
        return True, request['id']
        
    def process_ride_requests(self):
        # Process emergency requests first
        while not self.emergency_requests.is_empty():
            request = self.emergency_requests.pop()
            driver = self._find_nearest_driver(request['pickup_location'])
            if driver:
                self._assign_ride(request, driver['id'])
                
        # Process normal requests
        while not self.normal_requests.is_empty():
            request = self.normal_requests.dequeue()
            driver = self._find_nearest_driver(request['pickup_location'])
            if driver:
                self._assign_ride(request, driver['id'])
            else:
                self.normal_requests.enqueue(request)  # Re-queue if no driver found
                
    def _find_nearest_driver(self, pickup_location):
        available_drivers = self.driver_mgmt.get_available_drivers()
        nearest_driver = None
        min_distance = float('inf')
        
        for driver in available_drivers:
            if driver['current_location']:
                distance = self._calculate_distance(pickup_location, driver['current_location'])
                if distance < min_distance:
                    min_distance = distance
                    nearest_driver = driver
                    
        return nearest_driver
        
    def _assign_ride(self, request, driver_id):
        ride_id = str(uuid.uuid4())
        ride_data = {
            'id': ride_id,
            'request': request,
            'driver_id': driver_id,
            'status': 'assigned',
            'start_time': time.time()
        }
        
        self.active_rides.insert(ride_id, ride_data)
        
        # Update user and driver status
        user = self.user_mgmt.get_user_by_id(request['user_id'])
        driver = self.driver_mgmt.get_driver_by_id(driver_id)
        
        user['active_ride'] = ride_id
        driver['active_ride'] = ride_id
        
        self.driver_mgmt.set_driver_availability(driver_id, False)
        
        return ride_id

# social_rideshare.py
from data_structures import Graph

class SocialRideshare:
    def __init__(self):
        self.user_connections = Graph()  # Graph to represent user connections

    def add_connection(self, user1, user2):
        """
        Establishes a connection between two users for potential ridesharing.
        """
        self.user_connections.add_node(user1)
        self.user_connections.add_node(user2)
        self.user_connections.add_edge(user1, user2, 1)  # Edge weight represents connection strength

    def find_rideshare_partners(self, user, pickup_location, dropoff_location):
        """
        Finds potential rideshare partners based on user connections and route similarity.
        """
        potential_partners = self.user_connections.get_neighbors(user)
        matches = []

        for partner in potential_partners:
            # Here you can add logic to match routes based on similarity (e.g., same path, close destinations).
            matches.append(partner)

        return matches

# user_management.py
from data_structures import HashTable, DoublyLinkedList
import uuid

class UserManagement:
    def __init__(self):
        self.users = HashTable()  # Store user data
        self.active_sessions = HashTable()  # Track logged-in users
        self.users.load_from_file('users_data.json')
        
    def register_user(self, name, email, phone, password):
        user_id = str(uuid.uuid4())
        user_data = {
            'id': user_id,
            'name': name,
            'email': email,
            'phone': phone,
            'password': password,  # In real system, this should be hashed
            'ride_history': DoublyLinkedList(),
            'active_ride': None
        }
        
        if self.get_user_by_email(email):
            return False, "Email already registered"
            
        self.users.insert(user_id, user_data)
    
        # Save to file immediately
        self.users.save_to_file('users_data.json')
        return True, user_id
    
        
    def login_user(self, email, password):
        print("Debug: Users table contents:", self.users.table)  # Debug statement
        for bucket in self.users.table.values():
            print("Debug: Current bucket:", bucket)  # Debug statement
            if bucket:  # Ensure the bucket is not empty
                for key, user_data in bucket:
                    print("Debug: Checking user_data:", user_data)  # Debug statement
                    if isinstance(user_data, dict) and user_data.get('email') == email and user_data.get('password') == password:
                        session_id = str(uuid.uuid4())
                        self.active_sessions.insert(session_id, user_data['id'])
                        return True, session_id
        return False, "Invalid credentials"





        
    def get_user_by_id(self, user_id):
        return self.users.get(user_id)
        
    def get_user_by_email(self, email):
        for user_data in self.users.values():  # Use values() to get all user data
            if user_data['email'] == email:
                return user_data
        return None

    def update_user_profile(self, user_id, updates):
        user_data = self.users.get(user_id)
        if user_data:
            user_data.update(updates)
            self.users.insert(user_id, user_data)
            return True
        return False

#dashboards.py

import threading
import time
import os
import networkx as nx
import matplotlib.pyplot as plt
import sys

sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from user_management import UserManagement
from driver_management import DriverManagement
from ride_request import RideRequest
from location_service import LocationService
from emergency_handler import EmergencyHandler
from social_rideshare import SocialRideshare
from pricing import Pricing
from ride_history import RideHistory
from map_data import IslamabadMap
from data_structures import Graph
from data_structures import HashTable
from map_visualization import visualize_map, visualize_ride_path

# Initialize components
user_mgmt = UserManagement()
driver_mgmt = DriverManagement()
location_service = LocationService(IslamabadMap())
pricing = Pricing()
ride_history = RideHistory()
ride_request = RideRequest(user_mgmt, driver_mgmt)
emergency_handler = EmergencyHandler(ride_request, location_service, driver_mgmt)
social_rideshare = SocialRideshare()

class Dashboards:

    def run_user_login():
        print("\n--- User Login ---")
        email = input("Enter email: ")
        password = input("Enter password: ")

        success, result = user_mgmt.login_user(email, password)
        if success:
            session_id = result
            print("Login successful!")
            Dashboards.user_dashboard(session_id)  # Pass session_id to access the dashboard
        else:
            print(result)  # Print error message from login failure

    def run_user_signup():
        print("\n--- User Signup ---")
        name = input("Enter your name: ")
        email = input("Enter email: ")
        phone = input("Enter phone number: ")
        password = input("Enter password: ")

        success, result = user_mgmt.register_user(name, email, phone, password)
        if success:
            user_mgmt.users.save_to_file('users_data.json')
            print(f"Signup successful! Your user ID is {result}")
            Dashboards.run_user_login()  # After successful signup, redirect to login
        else:
            print(result)  # Print error message from signup failure

    def user_dashboard(user_id):
        while True:
            print("\n--- User Dashboard ---")
            print("1. Request Ride")
            print("2. View Ride History")
            print("3. Select Location")
            print("4. Book Emergency Ride")
            print("5. View Rideshare Connections")
            print("6. Add Rideshare Connection")
            print("7. Visualize Map")
            print("8. Logout")

            choice = input("Enter your choice: ")

            if choice == '1':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                # Prompt the user to select pickup and destination locations
                try:
                    pickup_index = int(input("Enter the number for your pickup location: "))
                    destination_index = int(input("Enter the number for your destination: "))
                    
                    # Validate user input
                    if pickup_index < 1 or pickup_index > len(all_locations) or destination_index < 1 or destination_index > len(all_locations):
                        print("Invalid selection. Please choose valid location numbers.")
                        return

                    pickup = all_locations[pickup_index - 1]
                    destination = all_locations[destination_index - 1]

                    # Ensure pickup and destination are not the same
                    if pickup == destination:
                        print("Pickup and destination locations cannot be the same. Please try again.")
                        return

                    # Validate the locations and proceed with the ride request
                    if islamabad_map.is_valid_location(pickup) and islamabad_map.is_valid_location(destination):
                        success, ride_id = ride_request.request_ride(user_id, pickup, destination)
                        if success:
                            print("Ride requested successfully. Ride ID:", ride_id)
                            visualize_ride_path(islamabad_map, pickup, destination)
                        else:
                            print("Failed to request ride.")
                    else:
                        print("Invalid locations. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter numbers corresponding to the locations.")

            elif choice == '2':
                history = ride_history.get_ride_history()
                print("--- Ride History ---")
                for ride in history:
                    print(ride)
            elif choice == '3':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                location = input("Select your current location: ")

                # Validate the location using IslamabadMap
                if islamabad_map.is_valid_location(location):
                    user_mgmt.update_user_profile(user_id, {'location': location})
                    print("Location updated.")
                else:
                    print("Invalid location. Please select a valid location from the available options.")

            elif choice == '4':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                try:
                    # Prompt the user to select pickup and destination locations
                    pickup_index = int(input("Enter the number for your pickup location: "))
                    destination_index = int(input("Enter the number for your emergency destination: "))

                    # Validate user input
                    if pickup_index < 1 or pickup_index > len(all_locations) or destination_index < 1 or destination_index > len(all_locations):
                        print("Invalid selection. Please choose valid location numbers.")
                        return

                    pickup = all_locations[pickup_index - 1]
                    destination = all_locations[destination_index - 1]

                    # Ensure pickup and destination are not the same
                    if pickup == destination:
                        print("Pickup and destination locations cannot be the same. Please try again.")
                        return

                    # Validate the locations and proceed with the emergency request
                    if islamabad_map.is_valid_location(pickup) and islamabad_map.is_valid_location(destination):
                        success, ride_id = emergency_handler.add_emergency_request(user_id, pickup, destination)
                        if success:
                            print("Emergency ride booked successfully. Ride ID:", ride_id)
                            visualize_ride_path(islamabad_map, pickup, destination)
                        else:
                            print("Failed to book emergency ride.")
                    else:
                        print("Invalid locations. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter numbers corresponding to the locations.")

            elif choice == '5':
                connections = social_rideshare.find_rideshare_partners(user_id, "", "")
                print("Potential rideshare partners:", connections)
            elif choice == '6':
                friend_id = input("Enter the ID of the friend to add as rideshare connection: ")
                social_rideshare.add_connection(user_id, friend_id)
                print("Rideshare connection added successfully.")
            elif choice == '7':
                visualize_map(location_service)
            elif choice == '8':
                print("Logging out...")
                break
            else:
                print("Invalid choice. Please try again.")

    def run_driver_login():
        print("\n--- Driver Login ---")
        email = input("Enter email: ")
        password = input("Enter password: ")

        success, result = driver_mgmt.login_driver(email, password)
        if success:
            driver_id = result
            print("Login successful!")
            Dashboards.driver_dashboard(driver_id)  # Pass driver_id to access the dashboard
        else:
            print(result)  # Print error message from login failure

    def run_driver_signup():
        print("\n--- Driver Signup ---")
        name = input("Enter your name: ")
        email = input("Enter email: ")
        phone = input("Enter phone number: ")
        password = input("Enter password: ")
        vehicle_type = input("Enter vehicle type: ")
        license_number = input("Enter license number: ")

        success, result = driver_mgmt.register_driver(name, email, phone, password, vehicle_type, license_number)
        if success:
            driver_mgmt.drivers.save_to_file('drivers_data.json')
            print(f"Signup successful! Your driver ID is {result}")
            Dashboards.run_driver_login()  # After successful signup, redirect to login
        else:
            print(result)  # Print error message from signup failure

    def driver_dashboard(driver_id):
        while True:
            print("\n--- Driver Dashboard ---")
            print("1. Toggle Availability")
            print("2. View Ride History")
            print("3. Update Location")
            print("4. Visualize Map")
            print("5. Logout")

            choice = input("Enter your choice: ")

            if choice == '1':
                status = input("Enter 'on' to be available or 'off' to go offline: ").lower()
                available = status == 'on'
                driver_mgmt.set_driver_availability(driver_id, available)
                print("Availability updated.")
            elif choice == '2':
                history = ride_history.get_ride_history()
                print("--- Ride History ---")
                for ride in history:
                    print(ride)
            elif choice == '3':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                try:
                    # Prompt the driver to select their current location
                    location_index = int(input("Enter the number for your current location: "))

                    # Validate user input
                    if location_index < 1 or location_index > len(all_locations):
                        print("Invalid selection. Please choose a valid location number.")
                        return

                    location = all_locations[location_index - 1]

                    # Validate the location and update the driver's location
                    if islamabad_map.is_valid_location(location):
                        driver_mgmt.update_driver_location(driver_id, location)
                        print("Location updated.")
                    else:
                        print("Invalid location. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter a number corresponding to the locations.")


#main.py
import threading

import networkx as nx
import matplotlib.pyplot as plt
from user_management import UserManagement
from driver_management import DriverManagement
from ride_request import RideRequest
from location_service import LocationService
from emergency_handler import EmergencyHandler
from social_rideshare import SocialRideshare
from pricing import Pricing
from ride_history import RideHistory
from map_data import IslamabadMap
from data_structures import Graph
from data_structures import HashTable
from polling import poll_file

from dashboards import Dashboards
from map_visualization import visualize_map, visualize_ride_path

# Initialize components
user_mgmt = UserManagement()
driver_mgmt = DriverManagement()
location_service = LocationService(IslamabadMap())
pricing = Pricing()
ride_history = RideHistory()
ride_request = RideRequest(user_mgmt, driver_mgmt)
emergency_handler = EmergencyHandler(ride_request, location_service, driver_mgmt)
social_rideshare = SocialRideshare()
dashboards = Dashboards()


# Import other required components...

def main():
    # Start polling threads for user and driver data
    user_poll_thread = threading.Thread(target=poll_file, args=('users_data.json', user_mgmt.users), daemon=True)
    driver_poll_thread = threading.Thread(target=poll_file, args=('drivers_data.json', driver_mgmt.drivers), daemon=True)
    user_poll_thread.start()
    driver_poll_thread.start()

    while True:
        try:
            print("\n--- Main Menu ---")
            print("1. User Login")
            print("2. Driver Login")
            print("3. User Signup")
            print("4. Driver Signup")
            print("5. Exit")
            
            choice = input("Enter your choice: ")
            
            if choice == '1':
                Dashboards.run_user_login()
            elif choice == '2':
                Dashboards.run_driver_login()
            elif choice == '3':
                Dashboards.run_user_signup()
            elif choice == '4':
                Dashboards.run_driver_signup()
            elif choice == '5':
                print("Exiting...")
                break
            else:
                print("Invalid choice. Please try again.")
        except KeyboardInterrupt:
            print("\nProgram interrupted. Exiting gracefully.")
            break

if __name__ == "__main__":
    main()
