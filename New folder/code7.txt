import threading
import time
import os
import networkx as nx
import matplotlib.pyplot as plt
import sys
import traceback

sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from user_management import UserManagement
from driver_management import DriverManagement
from ride_request import RideRequest
from location_service import LocationService
from emergency_handler import EmergencyHandler
from social_rideshare import SocialRideshare
from pricing import Pricing
from ride_history import RideHistory
from map_data import IslamabadMap, is_valid_location, LOCATIONS
from data_structures import Graph, HashTable
from map_visualization import visualize_map
from friend_management import FriendManagement
from save_load import save_data_to_file, load_data_from_file


class Dashboards:
    def __init__(self, user_mgmt, driver_mgmt, ride_request, location_service, pricing, ride_history, emergency_handler, friend_mgmt, islamabad_map):
        self.user_mgmt = user_mgmt
        self.driver_mgmt = driver_mgmt
        self.ride_request = ride_request
        self.location_service = location_service
        self.pricing = pricing
        self.ride_history = ride_history
        self.emergency_handler = emergency_handler
        self.friend_mgmt = friend_mgmt
        self.islamabad_map = islamabad_map

    def run_user_login(self):
        email = input("Enter email: ")
        password = input("Enter password: ")
        
        success, session_id = self.user_mgmt.login_user(email, password)
        if success:
            user_id = self.user_mgmt.active_sessions.get(session_id)  # Resolve user_id from session_id
            print("Login successful!")
            print("User ID after login:", user_id)
            self.user_dashboard(user_id)  # Pass correct user_id
        else:
            print("Invalid Login Details, Please try again.")


    def run_user_signup(self):
        print("\n--- User Signup ---")
        name = input("Enter your name: ")
        email = input("Enter email: ")
        phone = input("Enter phone number: ")
        password = input("Enter password: ")

        success, result = self.user_mgmt.register_user(name, email, phone, password)
        if success:
            save_data_to_file(self.user_mgmt, 'users_data.json')
            print(f"Signup successful! Your user ID is {result}")
            self.run_user_login()  # After successful signup, redirect to login
        else:
            print(result)  # Print error message from signup failure

    def user_dashboard(self, user_id):
        '''user_id = self.user_mgmt.get_user_by_session(user_id)
        if not user_id:
                print("Error: User ID not found for session.")
                return'''
            
                # Resolve session ID to actual user ID

        print("User ID in Dashboard:", user_id)
        while True:
            updates = self.ride_request.get_user_updates(user_id)
            if updates:
                if updates['type'] == 'ride_accepted':
                    print(f"\nRide accepted by driver {updates['driver']['name']}!")
                    print(f"Driver phone: {updates['driver']['phone']}")
                    print(f"Vehicle type: {updates['driver']['vehicle_type']}")

            print("\n--- User Dashboard ---")
            print("1. Request Ride")
            print("2. View Ride History")
            print("3. Select Location")
            print("4. Book Emergency Ride")
            print("5. View Friends")
            print("6. Add Friend")
            print("7. View Friend Requests")
            print("8. Visualize Map")
            print("9. Logout")
            print("10. See available drivers")
            print("11. Provide Feedback")
            print("12. Visualize Last Ride Path")

            choice = input("Enter your choice: ")

            if choice == '1':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                try:
                    # Prompt the user to select pickup and destination locations
                    pickup_index = int(input("Enter the number for your pickup location: "))
                    destination_index = int(input("Enter the number for your destination: "))

                    # Validate user input
                    if pickup_index < 1 or pickup_index > len(all_locations) or destination_index < 1 or destination_index > len(all_locations):
                        print("Invalid selection. Please choose valid location numbers.")
                        continue  # Continue to the next iteration of the loop

                    pickup = all_locations[pickup_index - 1]
                    destination = all_locations[destination_index - 1]

                    # Ensure pickup and destination are not the same
                    if pickup == destination:
                        print("Pickup and destination locations cannot be the same. Please try again.")
                        continue  # Continue to the next iteration of the loop

                    # Validate the locations and proceed with the ride request
                    if is_valid_location(pickup) and is_valid_location(destination):
                        success, ride_id = self.ride_request.request_ride(user_id, pickup, destination)
                        if success:
                            print("Ride requested successfully. Ride ID:", ride_id)
                            try:
                                islamabad_map.visualize_ride_path(pickup, destination)
                            except Exception as e:
                                print(f"Error visualizing path: {e}")
                                traceback.print_exc()
                        else:
                            print("Failed to request ride.")
                    else:
                        print("Invalid locations. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter numbers corresponding to the locations.")

            elif choice == '2':
                history = self.ride_history.get_ride_history()
                print("--- Ride History ---")
                for ride in history:
                    print(ride)
            elif choice == '3':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                location = input("Select your current location: ")

                # Validate the location using IslamabadMap
                if is_valid_location(location):
                    self.user_mgmt.update_user_profile(user_id, {'location': location})
                    print("Location updated.")
                else:
                    print("Invalid location. Please select a valid location from the available options.")

            elif choice == '4':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                try:
                    # Prompt the user to select pickup and destination locations
                    pickup_index = int(input("Enter the number for your pickup location: "))
                    destination_index = int(input("Enter the number for your emergency destination: "))

                    # Validate user input
                    if pickup_index < 1 or pickup_index > len(all_locations) or destination_index < 1 or destination_index > len(all_locations):
                        print("Invalid selection. Please choose valid location numbers.")
                        continue  # Continue to the next iteration of the loop

                    pickup = all_locations[pickup_index - 1]
                    destination = all_locations[destination_index - 1]

                    # Ensure pickup and destination are not the same
                    if pickup == destination:
                        print("Pickup and destination locations cannot be the same. Please try again.")
                        continue  # Continue to the next iteration of the loop

                    # Validate the locations and proceed with the emergency request
                    if is_valid_location(pickup) and is_valid_location(destination):
                        success, ride_id = self.emergency_handler.add_emergency_request(user_id, pickup, destination)
                        if success:
                            print("Emergency ride booked successfully. Ride ID:", ride_id)
                            islamabad_map.visualize_ride_path(self.location_service, pickup, destination)
                        else:
                            print("Failed to book emergency ride.")
                    else:
                        print("Invalid locations. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter numbers corresponding to the locations.")

            elif choice == '5':
                friends = self.friend_mgmt.get_friends_list(user_id)
                print("\n--- Your Friends ---")
                for idx, (friend_id, friend_data) in enumerate(friends, 1):
                    print(f"{idx}. {friend_data['name']} ({friend_data['email']})")

            elif choice == '6':
                users = self.friend_mgmt.display_all_users()
                if users:
                    choice = input("\nEnter the number of the user to add: ")
                    try:
                        idx = int(choice)
                        success, message = self.friend_mgmt.send_friend_request(user_id, idx, users)
                        print(message)
                    except ValueError:
                        print("Invalid input")

            elif choice == '7':
                pending_requests = self.friend_mgmt.get_pending_requests(user_id)
                if not pending_requests:
                    print("No pending friend requests")
                else:
                    print("\n--- Pending Friend Requests ---")
                    for idx, (from_id, from_user) in enumerate(pending_requests, 1):
                        print(f"{idx}. {from_user['name']} ({from_user['email']})")
                    choice = input("\nEnter request number to accept (or 0 to skip): ")
                    try:
                        idx = int(choice)
                        if idx > 0:
                            success, message = self.friend_mgmt.accept_friend_request(
                                user_id, idx, pending_requests)
                            print(message)
                    except ValueError:
                        print("Invalid input")
                        
            elif choice == '8':
                visualize_map(self.location_service)
            elif choice == '10':
                 self.see_available_drivers()
            elif choice == '9':
                print("Logging out...")
                break
            elif choice == '11':
                self.user_mgmt.provide_feedback(user_id)
            elif choice == '12':
                self.user_mgmt.visualize_last_active_ride_path(user_id)  # Call the new method
            else:
                print("Invalid choice. Please try again.")

    def see_available_drivers(self):
        print("\n--- Available Drivers ---")
        available_drivers = self.driver_mgmt.get_available_drivers()
        if not available_drivers:
            print("No drivers are currently available.")
            return

        for idx, driver in enumerate(available_drivers, 1):
            print(f"\nDriver {idx}:")
            print(f"Name: {driver['name']}")
            print(f"Vehicle Type: {driver['vehicle_type']}")
            print(f"Current Location: {driver.get('current_location', 'Unknown')}")
            print(f"Availability: {driver.get('availability', 'Not Set')}")


    def run_driver_login(self):
        print("\n--- Driver Login ---")
        email = input("Enter email: ")
        password = input("Enter password: ")

        success, result = self.driver_mgmt.login_driver(email, password)
        if success:
            driver_id = result
            print("Login successful!")
            self.driver_dashboard(driver_id)  # Pass driver_id to access the dashboard
        else:
            print(result)  # Print error message from login failure

    def run_driver_signup(self):
        print("\n--- Driver Signup ---")
        name = input("Enter your name: ")
        email = input("Enter email: ")
        phone = input("Enter phone number: ")
        password = input("Enter password: ")
        vehicle_type = input("Enter vehicle type: ")
        license_number = input("Enter license number: ")

        success, result = self.driver_mgmt.register_driver(name, email, phone, password, vehicle_type, license_number)
        if success:
            save_data_to_file(self.driver_mgmt,'drivers_data.json')
            print(f"Signup successful! Your driver ID is {result}")
            self.run_driver_login()  # After successful signup, redirect to login
        else:
            print(result)  # Print error message from signup failure

    

    def driver_dashboard(self, driver_id):
        while True:
            print("\n--- Driver Dashboard ---")
            print("1. Toggle Availability")
            print("2. View Ride History")
            print("3. Update Location")
            print("4. View Available Requests")
            print("5. Complete Ride")
            print("6. Visualize Map")
            print("7. Logout")
            print("8. See available drivers")
            print("9. Sync Active Rides")

            choice = input("Enter your choice: ")

            if choice == '1':
                status = input("Enter 'on' to be available or 'off' to go offline: ").lower()
                available = status == 'on'
                self.driver_mgmt.set_driver_availability(driver_id, available)
                print("Availability updated.")
            elif choice == '2':
                history = self.ride_history.get_ride_history()
                print("--- Ride History ---")
                for ride in history:
                    print(ride)
            elif choice == '3':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                try:
                    # Prompt the driver to select their current location
                    location_index = int(input("Enter the number for your current location: "))

                    # Validate user input
                    if location_index < 1 or location_index > len(all_locations):
                        print("Invalid selection. Please choose a valid location number.")
                        continue  # Continue to the next iteration of the loop

                    location = all_locations[location_index - 1]

                    # Validate the location and update the driver's location
                    if is_valid_location(location):
                        self.driver_mgmt.update_driver_location(driver_id, location)
                        print("Location updated.")
                    else:
                        print("Invalid location. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter a number corresponding to the locations.")

            elif choice == '4':
                # Ensure driver location is updated
                driver = self.driver_mgmt.get_driver_by_id(driver_id)
                if not driver['current_location']:
                    print("Please update your location first.")
                    continue

                # Call the view_ride_requests function to display and handle requests
                self.driver_mgmt.view_ride_requests(driver_id)

            elif choice == '5':
                driver = self.driver_mgmt.get_driver_by_id(driver_id)
                print(driver)
                if not driver['active_ride']:
                    print("You don't have any active rides.")
                    continue

                ride_id = driver['active_ride']
                success, message = self.ride_request.complete_ride(ride_id)
                print(message)

            elif choice == '6':
                visualize_map(self.location_service)

            elif choice == '7':
                print("Logging out...")

            elif choice == '8':
                 self.see_available_drivers()
                 break
            
            elif choice == '9':
                self.driver_mgmt.sync_active_rides_with_drivers(driver_id)

            else:
                print("Invalid choice. Please try again.")#data_structures.py
import json

class MinHeap:
    def __init__(self):
        self.heap = []

    def push(self, item):
        self.heap.append(item)
        self._heapify_up(len(self.heap) - 1)

    def pop(self):
        if len(self.heap) == 0:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()
        root = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)
        return root

    def _heapify_up(self, index):
        parent = (index - 1) // 2
        if index > 0 and self.heap[index][0] < self.heap[parent][0]:  # Compare only priorities
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            self._heapify_up(parent)

    def _heapify_down(self, index):
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        if left < len(self.heap) and self.heap[left][0] < self.heap[smallest][0]:  # Compare only priorities
            smallest = left
        if right < len(self.heap) and self.heap[right][0] < self.heap[smallest][0]:  # Compare only priorities
            smallest = right
        if smallest != index:
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
            self._heapify_down(smallest)

    def peek(self):
        if self.heap:
            return self.heap[0]
        return None

    def is_empty(self):
        return len(self.heap) == 0

    def size(self):
        return len(self.heap)


class Graph:
    def __init__(self):
        self.nodes = {}

    def add_node(self, location):
        if location not in self.nodes:
            self.nodes[location] = {}

    def add_edge(self, start, end, distance):
        if start in self.nodes and end in self.nodes:
            self.nodes[start][end] = distance
            self.nodes[end][start] = distance  # Since it's an undirected graph

    def get_neighbors(self, node):
        return self.nodes.get(node, {})

    def dijkstra(self, start):
        """
        Implementation of Dijkstra's shortest path algorithm using MinHeap.
        
        Args:
            start: Starting node
            
        Returns:
            Dictionary of shortest distances to all nodes from start node
            Dictionary of previous nodes in the shortest path
        """
        # Initialize distances with infinity for all nodes except start
        distances = {node: float('infinity') for node in self.nodes}
        distances[start] = 0
        
        # Dictionary to store the previous node in shortest path
        previous = {node: None for node in self.nodes}
        
        # Create min heap for storing vertices to visit
        pq = MinHeap()
        pq.push((0, start))  # (distance, node)
        
        # Set to keep track of visited nodes
        visited = set()
        
        while not pq.is_empty():
            # Get the node with minimum distance
            current_distance, current_node = pq.pop()
            
            # If we've already processed this node, skip it
            if current_node in visited:
                continue
                
            # Mark node as visited
            visited.add(current_node)
            
            # If current distance is greater than known distance, skip
            if current_distance > distances[current_node]:
                continue
            
            # Check all neighbors of current node
            for neighbor, weight in self.nodes[current_node].items():
                # Skip if neighbor is already visited
                if neighbor in visited:
                    continue
                    
                # Calculate tentative distance to neighbor
                distance = current_distance + weight
                
                # If we found a shorter path, update it
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_node
                    pq.push((distance, neighbor))
        
        return distances, previous

    def get_shortest_path(self, start, end):
        distances, previous = self.dijkstra(start)
        if distances[end] == float('infinity'):
            return None  # No path exists

        path = []
        current = end
        while current is not None:
            path.append(current)
            current = previous[current]
        path.reverse()
        
        return path  # Return only the path

        

    def get_shortest_path_distance(self, start, end):
        if start not in self.nodes or end not in self.nodes:
            return None
        distances, _ = self.dijkstra(start)
        return distances.get(end, float('inf'))



    def get_all_paths(self, start):
        """
        Gets all shortest paths from start node to all other nodes.
        
        Args:
            start: Starting node
            
        Returns:
            Dictionary with end nodes as keys and (distance, path) tuples as values
        """
        distances, previous = self.dijkstra(start)
        paths = {}
        
        for end in self.nodes:
            if end == start:
                paths[end] = (0, [start])
                continue
                
            if distances[end] == float('infinity'):
                paths[end] = (None, None)
                continue
                
            # Reconstruct path
            path = []
            current = end
            while current is not None:
                path.append(current)
                current = previous[current]
            path.reverse()
            
            paths[end] = (distances[end], path)
            
        return paths
    
    def to_dict(self):
        """
        Converts the Graph into a dictionary for serialization.
        """
        return {"nodes": self.nodes}

    @classmethod
    def from_dict(cls, data):
        """
        Reconstructs a Graph from a dictionary.
        """
        new_graph = cls()
        new_graph.nodes = data.get("nodes", {})
        return new_graph

class DoublyLinkedList:
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None
            self.prev = None

    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, data):
        new_node = self.Node(data)
        if not self.head:
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def traverse_forward(self):
        current = self.head
        while current:
            print(current.data)
            current = current.next

    def traverse_backward(self):
        current = self.tail
        while current:
            print(current.data)
            current = current.prev

    def to_list(self):
        """Convert linked list to Python list"""
        result = []
        current = self.head
        while current:
            # Handle nested objects that might have to_dict or to_list methods
            if hasattr(current.data, 'to_dict'):
                result.append(current.data.to_dict())
            elif hasattr(current.data, 'to_list'):
                result.append(current.data.to_list())
            else:
                result.append(current.data)
            current = current.next
        return result

    def to_dict(self):
        """Convert to dictionary for JSON serialization compatibility"""
        return {'data': self.to_list()}

    @classmethod
    def from_list(cls, data_list):
        """Create linked list from Python list"""
        ll = cls()
        for item in data_list:
            # Handle dictionary input for nested objects
            if isinstance(item, dict):
                if 'data' in item and isinstance(item['data'], list):
                    # Handle nested LinkedList
                    ll.append(cls.from_list(item['data']))
                else:
                    # Handle nested HashTable
                    ll.append(HashTable.from_dict(item))
            else:
                ll.append(item)
        return ll
    
    def delete(self, data):
        current = self.head
        while current:
            if current.data == data:
                if current.prev:
                    current.prev.next = current.next
                if current.next:
                    current.next.prev = current.prev
                if current == self.head:
                    self.head = current.next
                if current == self.tail:
                    self.tail = current.prev
                return True
        return False

    def __str__(self):
        """String representation for debugging"""
        return f"DoublyLinkedList({self.to_list()})"

    def __eq__(self, other):
        """Enable equality comparison"""
        if not isinstance(other, DoublyLinkedList):
            return False
        return self.to_list() == other.to_list()
    
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]  # List of lists for chaining

    def _hash(self, key):
        """Compute the hash index for a key."""
        return hash(key) % self.size

    def insert(self, key, value):
        """Insert or update a key-value pair."""
        index = self._hash(key)
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                self.table[index][i] = (key, value)  # Update existing key
                return
        self.table[index].append((key, value))  # Add new key-value pair

    def get(self, key):
        """Retrieve value by key."""
        index = self._hash(key)
        for k, v in self.table[index]:
            if k == key:
                return v
        return None

    def delete(self, key):
        """Delete a key-value pair."""
        index = self._hash(key)
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                del self.table[index][i]
                return True
        return False

    def values(self):
        """Return all values (dictionary-like)."""
        return [v for bucket in self.table for k, v in bucket]

    def items(self):
        """Return all key-value pairs."""
        return [(k, v) for bucket in self.table for k, v in bucket]

    def to_dict(self):
        """Convert to a dictionary for JSON serialization."""
        result = {}
        for bucket in self.table:
            for key, value in bucket:
                # Handle nested objects that might have to_dict method
                if hasattr(value, 'to_dict'):
                    result[str(key)] = value.to_dict()
                # Handle nested objects that might have to_list method
                elif hasattr(value, 'to_list'):
                    result[str(key)] = value.to_list()
                else:
                    result[str(key)] = value
        return result

    @classmethod
    def from_dict(cls, data_dict):
        """Create HashTable from dictionary"""
        ht = cls()
        # Clear the initial empty buckets
        ht.table = [[] for _ in range(ht.size)]
        # Insert each key-value pair using the existing insert method
        for key, value in data_dict.items():
            ht.insert(key, value)
        return ht

    def buckets(self):
        """Return raw table structure for iteration."""
        return self.table

    

    
class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, item):
        self.queue.append(item)

    def dequeue(self):
        if self.queue:
            return self.queue.pop(0)
        return None

    def is_empty(self):
        return len(self.queue) == 0

    def peek(self):
        if self.queue:
            return self.queue[0]
        return None
    
    def to_dict(self):
        """
        Converts the Queue into a dictionary for serialization.
        """
        return {"queue": self.queue}

    @classmethod
    def from_dict(cls, data):
        """
        Reconstructs a Queue from a dictionary.
        """
        new_queue = cls()
        new_queue.queue = data.get("queue", [])
        return new_queue

class PriorityQueue(MinHeap):
    def __init__(self):
        super().__init__()

    def push(self, priority, item):
        super().push((priority, item))  # Push a tuple of (priority, item)

    def pop(self):
        return super().pop()[1] if self.heap else None  # Return only the item

    def peek(self):
        return self.heap[0][1] if self.heap else None  # Return only the item

    def to_dict(self):
        return {"heap": self.heap}
    
        
    def to_list(self):
        return [item for _, item in self.heap]  # Extract items from the heap



    @classmethod
    def from_dict(cls, data):
        new_pq = cls()
        new_pq.heap = data.get("heap", [])
        return new_pq
    
class AVLTree:
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.value = value
            self.height = 1
            self.left = None
            self.right = None

    def __init__(self):
        self.root = None

    # Implement AVL Tree methods (insert, delete, rotate, balance) as needed

# Additional data structures can be added here if necessary for the project requirements.
from data_structures import HashTable, DoublyLinkedList, PriorityQueue
from save_load import save_data_to_file, load_data_from_file
import uuid
import time

class DriverManagement:
    def __init__(self):
        # Load drivers from file or initialize an empty HashTable
        self.drivers = load_data_from_file('drivers_data.json', HashTable) or HashTable()
        self.active_drivers = HashTable()  # Currently available drivers

    def register_driver(self, name, email, phone, password, vehicle_type, license_number):
        driver_id = str(uuid.uuid4())
        driver_data = {
            'id': driver_id,
            'name': name,
            'email': email,
            'phone': phone,
            'password': password,  # Should be hashed in real system
            'vehicle_type': vehicle_type,
            'license_number': license_number,
            'rating': 0.0,
            'total_ratings': 0,
            'current_location': None,
            'active_ride': None,
            'ride_history': DoublyLinkedList()
        }

        if self.get_driver_by_email(email):
            return False, "Email already registered"

        self.drivers.insert(driver_id, driver_data)
        # Save to file immediately
        save_data_to_file(self.drivers, 'drivers_data.json')
        return True, driver_id

    def login_driver(self, email, password):
        print("Debug: Drivers table contents:", self.drivers.table)  # Debug statement
        for bucket in self.drivers.table:  # Iterate over each bucket
            print("Debug: Current bucket:", bucket)  # Debug statement
            if bucket:  # Ensure the bucket is not empty
                for driver_id, driver_data in bucket:  # Iterate through the list of key-value pairs
                    print("Debug: Checking driver_data:", driver_data)  # Debug statement
                    if isinstance(driver_data, dict) and driver_data.get('email') == email and driver_data.get('password') == password:
                        return True, driver_id
        return False, "Invalid credentials"

    
    def update_driver(self, driver):
        # Logic to save the updated driver data back to the data store
        drivers_data = load_data_from_file('drivers.json', dict)  # Load existing drivers
        drivers_data[driver['id']] = driver  # Update the driver using the ID as the key
        save_data_to_file(drivers_data, 'drivers.json')  # Save updated drivers

    def update_driver_location(self, driver_id, location):
        driver_data = self.drivers.get(driver_id)
        if driver_data:
            driver_data['current_location'] = location
            self.drivers.insert(driver_id, driver_data)
            # Save updated data
            save_data_to_file(self.drivers, 'drivers_data.json')
            return True
        return False
    

    def set_driver_availability(self, driver_id, available):
        driver_data = self.drivers.get(driver_id)
        if driver_data:
            driver_data['availability'] = available  # Add or update availability
            self.drivers.insert(driver_id, driver_data)
            save_data_to_file(self.drivers, 'drivers_data.json')  # Save changes
        if available:
            self.active_drivers.insert(driver_id, driver_data)
        else:
            self.active_drivers.delete(driver_id)
            return True
        return False

    def get_driver_by_email(self, email):
        # Check if any driver has the given email
        for driver_data_list in self.drivers.table:
            if driver_data_list:  # Ensure there is data in this bucket
                for _, driver in driver_data_list:
                    if driver['email'] == email:
                        return driver
        return None

    def get_available_drivers(self):
        return [driver for driver in self.drivers.values() if driver.get('availability')]


    def get_driver_by_id(self, driver_id):
        return self.drivers.get(driver_id)
    
  
    '''def view_ride_requests(self, driver_id):
        ride_requests = load_data_from_file('ride_requests.json', list) or []
        
        if not ride_requests:
            print("No ride requests available.")
            return

        print("\n--- Ride Requests ---")
        for idx, request in enumerate(ride_requests, start=1):
            print(f"{idx}. Pickup: {request['pickup_location']}, Dropoff: {request['dropoff_location']}, User ID: {request['user_id']}")

        try:
            choice = int(input("Enter the number of the ride to accept: ")) - 1
            if 0 <= choice < len(ride_requests):
                selected_request = ride_requests.pop(choice)
                
                # Move to active rides
                active_rides = load_data_from_file('active_rides.json', list) or []
                active_rides.append({
                    "id": selected_request["id"],
                    "user_id": selected_request["user_id"],
                    "driver_id": driver_id,
                    "pickup_location": selected_request["pickup_location"],
                    "dropoff_location": selected_request["dropoff_location"],
                    "status": "ongoing",
                    "start_time": time.time()
                })

                # Save updated files
                save_data_to_file(ride_requests, 'ride_requests.json')
                save_data_to_file(active_rides, 'active_rides.json')
                print("Ride accepted successfully!")
            else:
                print("Invalid selection.")
        except ValueError:
            print("Invalid input. Please enter a valid number.")'''
    

    def view_ride_requests(self, driver_id):
        # Load raw data from JSON file
        ride_requests_raw = load_data_from_file('normal_requests.json', dict)
        print(f"Debug: Raw ride requests loaded:\n{ride_requests_raw}")

        # Check if the raw data contains the 'queue' key
        if not ride_requests_raw or 'queue' not in ride_requests_raw:
            print("No ride requests available.")
            return

        # Extract the queue and convert to PriorityQueue
        try:
            ride_requests = PriorityQueue()
            for request in ride_requests_raw['queue']:
                # Add requests to the priority queue with their distance or priority
                priority = request.get('priority', 2)  # Default to priority 2 if missing
                ride_requests.push(priority, request)
            print(f"Debug: PriorityQueue state after loading:\n{ride_requests.heap}")
        except Exception as e:
            print(f"Error processing ride requests: {e}")
            return

        if ride_requests.is_empty():
            print("No ride requests available.")
            return

        print("\n--- Ride Requests ---")
        # Sort requests by priority for display
        requests_list = sorted(ride_requests.heap, key=lambda x: x[0])  # Sort by priority
        for idx, (_, request) in enumerate(requests_list, start=1):
            # Use .get() to avoid KeyError
            print(f"{idx}. Priority: {request.get('priority', 'N/A')}, "
                  f"Pickup: {request.get('pickup_location', 'N/A')}, "
                  f"Dropoff: {request.get('dropoff_location', 'N/A')}, "
                  f"User  ID: {request.get('user_id', 'N/A')}")

        try:
            # Prompt driver to select a ride
            choice = int(input("Enter the number of the ride to accept: ")) - 1
            if 0 <= choice < len(requests_list):
                # Select the chosen request
                selected_request = requests_list.pop(choice)[1]

                # Debug: Show the selected request
                print(f"Debug: Selected request details:\n{selected_request}")

                # Update the queue
                ride_requests.heap = [(priority, req) for priority, req in requests_list]
                save_data_to_file({'queue': ride_requests.to_list()}, 'normal_requests.json')
                print("Debug: Updated normal requests saved successfully.")

                # Move the selected request to active rides
                active_rides = load_data_from_file('active_rides.json', dict) or {}
                ride_id = selected_request.get("id")  # Get the ride ID from the selected request
                active_ride = {
                    "id": ride_id,
                    "user_id": selected_request.get("user_id"),
                    "driver_id": driver_id,
                    "pickup_location": selected_request.get("pickup_location"),
                    "dropoff_location": selected_request.get("dropoff_location"),
                    "status": "ongoing",
                    "start_time": time.time()
                }
                active_rides[ride_id] = active_ride  # Use ride_id as the key
                save_data_to_file(active_rides, 'active_rides.json')  # Save the updated active rides

                print(f"Debug: Added ride to active rides:\n{active_ride}")
                print("Ride accepted successfully!")
            else:
                print("Invalid selection. Please choose a valid ride number.")
        except ValueError:
            print("Invalid input. Please enter a valid number.")

    def sync_active_rides_with_drivers(self, driver_id):
        # Load active rides as a dictionary
        active_rides = load_data_from_file('active_rides.json', dict) or {}
        print(f"Debug: Loaded active rides: {active_rides}")

        # Load drivers data as a dictionary
        drivers_data = load_data_from_file('drivers_data.json', dict) or {}
        print(f"Debug: Loaded drivers data: {drivers_data}")

        # Create a mapping of driver IDs to their active rides
        driver_to_active_ride = {}
        for ride_id, ride in active_rides.items():  # Iterate over the dictionary
            driver_to_active_ride[ride['driver_id']] = ride['id']

        print(f"Debug: Driver to active ride mapping: {driver_to_active_ride}")

        # Check if the specified driver ID exists in the drivers data
        if driver_id in drivers_data:
            driver = drivers_data[driver_id]
            # Update the driver's active_ride field
            if driver_id in driver_to_active_ride:
                driver['active_ride'] = driver_to_active_ride[driver_id]
            else:
                driver['active_ride'] = None

            # Save updated drivers data
            save_data_to_file(drivers_data, 'drivers_data.json')
            print("Debug: Updated drivers_data.json successfully.")
        else:
            print(f"Debug: Driver with ID {driver_id} not found in drivers data.")from data_structures import PriorityQueue
from save_load import save_data_to_file, load_data_from_file
import time
import uuid

class EmergencyHandler:
    def __init__(self, ride_request, location_service, driver_management, file_path='emergency_requests.json'):
        """
        Initializes EmergencyHandler and loads emergency requests from the specified file.
        """
        self.ride_request = ride_request
        self.location_service = location_service
        self.driver_mgmt = driver_management
        self.file_path = file_path
        self.emergency_requests = load_data_from_file(self.file_path, PriorityQueue)

    def add_emergency_request(self, user_id, pickup_location, dropoff_location):
        """
        Adds an emergency ride request to the queue with the highest priority.
        Simulates forwarding the request to a 911-like service.
        """
        request = {
            'id': str(uuid.uuid4()),
            'user_id': user_id,
            'pickup_location': pickup_location,
            'dropoff_location': dropoff_location,
            'timestamp': time.time(),
        }
        print(f"Emergency request forwarded to 911 service: {request}")
        self.emergency_requests.push(1, request)  # Priority 1 for emergency requests
        # Save updated emergency requests to file
        save_data_to_file(self.emergency_requests, self.file_path)
        return True, request['id']

    def dispatch_emergency_ride(self):
        """
        Processes the emergency ride queue and dispatches the nearest available emergency vehicle.
        Simulates fetching emergency vehicle location data from a 911-like service.
        """
        if self.emergency_requests.is_empty():
            return False, "No emergency requests in the queue."

        request = self.emergency_requests.pop()
        # Save updated emergency requests to file
        save_data_to_file(self.emergency_requests, self.file_path)

        # Simulate receiving nearest vehicle location from 911 service
        print(f"Fetching nearest emergency vehicle for request: {request['id']}")
        driver = self._find_nearest_driver(request['pickup_location'])

        if driver:
            ride_id = self.ride_request._assign_ride(request, driver['id'])
            return True, f"Emergency ride dispatched. Ride ID: {ride_id}"

        return False, "No available emergency vehicles for dispatch."

    def _find_nearest_driver(self, pickup_location):
        """
        Finds the nearest available driver for the given pickup location.
        Simulates receiving driver data from 911.
        """
        available_drivers = self.driver_mgmt.get_available_drivers()
        print("Available drivers fetched from 911 system.")
        nearest_driver = None
        min_distance = float('inf')

        for driver in available_drivers:
            if driver['current_location']:
                distance = self.location_service.get_shortest_path_distance(pickup_location, driver['current_location'])
                if distance < min_distance:
                    min_distance = distance
                    nearest_driver = driver

        return nearest_driver
# friend_management.py
from data_structures import HashTable
from save_load import save_data_to_file, load_data_from_file

class FriendManagement:
    def __init__(self, user_management, file_path='friend_data.json'):
        self.user_mgmt = user_management
        self.friend_requests = HashTable()  # Store pending friend requests
        self.friends_list = HashTable()     # Store accepted friends
        self.file_path = file_path

        # Load existing data from file
        data = load_data_from_file(self.file_path, dict) or {}
        self.friend_requests = HashTable.from_dict(data.get('friend_requests', {}))
        self.friends_list = HashTable.from_dict(data.get('friends_list', {}))

    def save_to_file(self):
        data = {
            'friend_requests': self.friend_requests.to_dict(),
            'friends_list': self.friends_list.to_dict()
        }
        save_data_to_file(data, self.file_path)

    def display_all_users(self):
        """Display all users with numbers for selection."""
        users = []
        for bucket in self.user_mgmt.users.table.values():
            if bucket:
                for user_id, user_data in bucket:
                    users.append((user_id, user_data))
        
        print("\n--- Available Users ---")
        for idx, (user_id, user_data) in enumerate(users, 1):
            print(f"{idx}. {user_data['name']} ({user_data['email']})")
        return users

    def send_friend_request(self, from_user_id, to_user_idx, users_list):
        """Send a friend request to selected user."""
        if to_user_idx < 1 or to_user_idx > len(users_list):
            return False, "Invalid user selection"
            
        to_user_id = users_list[to_user_idx - 1][0]
        print(f"Debug: Sending friend request to {to_user_id} from {from_user_id}")  # Debug

        # Validate and ensure correct user_id is used
        real_user_id = self.user_mgmt.active_sessions.get(from_user_id) or from_user_id
        
        # FIX: Check directly in user database instead of active_sessions
        if not self.user_mgmt.users.get(real_user_id):
            print("Error: User ID not found in user database.")
            return False, "Invalid user ID"
            
        if to_user_id == from_user_id:
            return False, "Cannot send friend request to yourself"
            
        # Check if already friends
        if self.are_friends(from_user_id, to_user_id):
            return False, "Already friends with this user"
            
        # Check if request already pending
        pending_requests = self.friend_requests.get(to_user_id) or []
        if from_user_id in pending_requests:
            return False, "Friend request already pending"
            
        # Store the friend request
        if not self.friend_requests.get(to_user_id):
            self.friend_requests.insert(to_user_id, [])
        pending_requests.append(from_user_id)
        self.friend_requests.insert(to_user_id, pending_requests)
        
        # Save immediately after sending request
        self.save_to_file()
        
        return True, "Friend request sent successfully"


    '''def get_pending_requests(self, user_id):
        """Get list of pending friend requests for a user."""
        pending_users = []
        print(f"Debug: Friend Requests Table: {self.friend_requests.to_dict()}")  # Debug statement
        print(f"Debug: Current User ID: {user_id}")  # Debug current user ID

        for bucket in self.friend_requests.table.values():
            if bucket:
                for to_user_id, from_user_list in bucket:
                    # Reverse lookup: Check if current user sent a request to this recipient
                    if user_id in from_user_list:
                        print(f"Debug: Match found for request sent by {user_id} to {to_user_id}")  # Confirm match
                        user_data = self.user_mgmt.get_user_by_id(to_user_id)
                        if user_data:
                            pending_users.append((to_user_id, user_data))
        
        return pending_users
        #this function used to show you the requests that you have sent to other users
        # say you logged in as hh, it shows the requests you as hh sent to others. not what others sent to you'''
    
    def get_pending_requests(self, user_id):
        """Get list of pending friend requests for a user."""
        pending_users = []
        requests_dict = self.friend_requests.to_dict()  # Get the dictionary representation
        print(f"Debug: Friend Requests Table: {requests_dict}")
        print(f"Debug: Current User ID: {user_id}")
        
        # Use the dictionary you just retrieved
        for to_user_id, from_user_list in requests_dict.items():
            if to_user_id == user_id:  # Look for incoming requests
                print(f"Debug: Match found for pending request to {user_id}")
                for from_user_id in from_user_list:
                    # Fetch user data
                    print(f"Debug: UserManagement internal data: {self.user_mgmt.__dict__}")  # This will show us the internal state
                    print(f"Debug: Type of user_mgmt: {type(self.user_mgmt)}")
                    user_data = self.user_mgmt.get_user_by_id(from_user_id)
                    print(f"Debug: Fetched user data for {from_user_id}: {user_data}")
                    if user_data:  # If valid user data is returned
                        pending_users.append((from_user_id, user_data))
                    else:
                        print(f"Debug: No user data found for {from_user_id}")
    
        # Debug statement to check the final list
        print(f"Debug: Pending Users: {pending_users}")
        return pending_users





    def accept_friend_request(self, user_id, from_user_idx, pending_requests):
        """Accept a friend request."""
        if from_user_idx < 1 or from_user_idx > len(pending_requests):
            return False, "Invalid selection"
        
        # Identify the sender of the request
        from_user_id = pending_requests[from_user_idx - 1][0]
        print(f"Debug: Accepting request from {from_user_id} for user {user_id}")

        # Add each user to the other's friend list
        if not self.friends_list.get(user_id):
            self.friends_list.insert(user_id, [])
        if not self.friends_list.get(from_user_id):
            self.friends_list.insert(from_user_id, [])

        # Update friend lists for both users
        user_friends = self.friends_list.get(user_id)
        from_user_friends = self.friends_list.get(from_user_id)
        
        if from_user_id not in user_friends:
            user_friends.append(from_user_id)
        if user_id not in from_user_friends:
            from_user_friends.append(user_id)
        
        self.friends_list.insert(user_id, user_friends)
        self.friends_list.insert(from_user_id, from_user_friends)

        # Remove the accepted request from pending requests
        pending_requests = self.friend_requests.get(user_id)
        pending_requests.remove(from_user_id)
        self.friend_requests.insert(user_id, pending_requests)
        
        # Save changes immediately
        self.save_to_file()

        return True, "Friend request accepted successfully"


    def are_friends(self, user_id1, user_id2):
        """Check if two users are friends."""
        user1_friends = self.friends_list.get(user_id1) or []
        return user_id2 in user1_friends

    def get_friends_list(self, user_id):
        """Get list of friends for a user."""
        friends = self.friends_list.get(user_id) or []
        friend_users = []
        
        for friend_id in friends:
            user_data = self.user_mgmt.get_user_by_id(friend_id)
            if user_data:
                friend_users.append((friend_id, user_data))
                
        return friend_users
from data_structures import Graph
from map_data import IslamabadMap
from save_load import save_data_to_file, load_data_from_file

class LocationService:
    def __init__(self, map_data: IslamabadMap, file_path='location_service.json'):
        self.map_data = map_data  
        self.file_path = file_path
        self.graph = load_data_from_file(self.file_path, Graph)
        if not self.graph:
            self.graph = Graph()
            self._initialize_map()
            save_data_to_file(self.file_path, self.graph)

    def _initialize_map(self):
        """
        Initializes the graph with locations and distances from the IslamabadMap instance.
        """
        # Add all locations as nodes
        locations = self.map_data.get_all_locations()
        for location in locations:
            self.graph.add_node(location)

        # Add all distances as edges
        distances = self.map_data.get_distances()  # Use the get_distances method
        for (start, end), distance in distances.items():
            self.graph.add_edge(start, end, distance)
            # Add reverse direction since roads are typically bidirectional
            self.graph.add_edge(end, start, distance)
        
        return self.graph

    def get_shortest_path(self, start, end):
        """Get the shortest path and its distance between two locations."""
        if not self.is_valid_location(start) or not self.is_valid_location(end):
            return None, "Invalid locations provided."
        
        try:
            distances, previous_nodes = self.graph.dijkstra_with_path(start)
            if distances[end] == float('inf'):
                return None, "No path exists between the specified locations."
            
            # Reconstruct path
            path = []
            current = end
            while current:
                path.insert(0, current)
                current = previous_nodes.get(current)
                
            return path, distances[end]
        except Exception as e:
            return None, f"Error calculating path: {str(e)}"

    def get_nearby_locations(self, location, max_distance):
        """Gets all locations within a specified distance from the given location."""
        if not self.is_valid_location(location):
            return []
        
        try:
            distances, _ = self.graph.dijkstra(location)
            return [loc for loc, dist in distances.items() if 0 < dist <= max_distance]
        except Exception:
            return []

    def get_distance_between(self, start, end):
        """Returns the shortest path distance between two locations."""
        if not self.is_valid_location(start) or not self.is_valid_location(end):
            return None
            
        try:
            distances, _ = self.graph.dijkstra(start)
            distance = distances.get(end)
            return None if distance == float('inf') else distance
        except Exception:
            return None

    def is_valid_location(self, location):
        """Checks if a location exists in the map."""
        return location in self.graph.nodes

    def save(self):
        """Save the current state of the graph."""
        save_data_to_file(self.graph, self.file_path)
#main.py
import threading
import networkx as nx
import matplotlib.pyplot as plt
from user_management import UserManagement
from driver_management import DriverManagement
from friend_management import FriendManagement
from ride_request import RideRequest
from location_service import LocationService
from emergency_handler import EmergencyHandler
from social_rideshare import SocialRideshare
from pricing import Pricing
from ride_history import RideHistory
from map_data import IslamabadMap
from data_structures import Graph
from data_structures import HashTable
from polling import poll_file, reload_drivers, reload_users

from dashboards import Dashboards
from map_visualization import visualize_map


def initialize_system():
    """Initialize all system components in the correct order"""
    # Initialize base services first
    
    islamabad_map = IslamabadMap()
    location_service = LocationService(islamabad_map)
    pricing = Pricing()
    
    # Initialize management systems
    user_mgmt = UserManagement(islamabad_map)
    driver_mgmt = DriverManagement()
    friend_mgmt = FriendManagement(user_mgmt)
    ride_history = RideHistory()
    
    # Initialize ride request system with all required dependencies
    ride_request = RideRequest(
        user_management=user_mgmt,
        driver_management=driver_mgmt,
        location_service=location_service,
        pricing=pricing
    )
    
    # Initialize additional services that depend on core components
    emergency_handler = EmergencyHandler(ride_request, location_service, driver_mgmt)
    social_rideshare = SocialRideshare()
    
    # Initialize dashboard last as it depends on all other components
    dashboards = Dashboards(user_mgmt, driver_mgmt, ride_request, location_service, pricing, ride_history, emergency_handler, friend_mgmt, islamabad_map)
    
    return {
        'user_mgmt': user_mgmt,
        'driver_mgmt': driver_mgmt,
        'location_service': location_service,
        'pricing': pricing,
        'ride_request': ride_request,
        'emergency_handler': emergency_handler,
        'social_rideshare': social_rideshare,
        'dashboards': dashboards,
        'ride_history': ride_history
    }

def main():

    # Initialize the system
    system = initialize_system()
    Dashboards = system['dashboards']

    # Start polling threads for user and driver data
    user_poll_thread = threading.Thread(target=poll_file, args=('users_data.json', reload_users, 1), daemon=True)
    driver_poll_thread = threading.Thread(target=poll_file, args=('drivers_data.json', reload_drivers, 1), daemon=True)
    user_poll_thread.start()
    driver_poll_thread.start()

    while True:
        try:
            print("\n--- Main Menu ---")
            print("1. User Login")
            print("2. Driver Login")
            print("3. User Signup")
            print("4. Driver Signup")
            print("5. Exit")
            
            choice = input("Enter your choice: ")
            
            if choice == '1':
                Dashboards.run_user_login()
            elif choice == '2':
                Dashboards.run_driver_login()
            elif choice == '3':
                Dashboards.run_user_signup()
            elif choice == '4':
                Dashboards.run_driver_signup()
            elif choice == '5':
                print("Exiting...")
                break
            else:
                print("Invalid choice. Please try again.")
        except KeyboardInterrupt:
            print("\nProgram interrupted. Exiting gracefully.")
            break

if __name__ == "__main__":
    main()
import networkx as nx
from data_structures import Graph
from save_load import save_data_to_file, load_data_from_file


# Dictionary of locations with their coordinates (x, y)
'''LOCATIONS = {
    # Sectors
    'F-6 Markaz': (0, 0),
    'F-7 Markaz': (2, 1),
    'G-9 Markaz': (-2, 3),
    'I-8 Markaz': (-4, 5),
    'E-11 Markaz': (-3, -2),
    'F-10 Markaz': (1, 3),
    'G-11 Markaz': (-1, 4),
    'F-17': (5, 7),
    'E-11': (-3, -3),
    'G-10': (0, 4),
    'D-12': (-5, -1),
    'F-11': (2, 4),
    'G-6': (-1, 1),

    # Universities
    'IIUI': (-6, 6),
    'Air University': (3, 5),
    'FAST University': (1, 2),
    'COMSATS': (4, 3),
    'NUST': (-2, 6),

    # Landmarks
    'Faisal Mosque': (0, 5),
    'Shakarparian': (3, -1),
    'Pakistan Monument': (2, -2),
    'Daman-e-Koh': (1, 6),
    'Centaurus Mall': (2, 0),
    'Serena Hotel': (1, 1)
}'''

'''# Dictionary of locations with their coordinates (x, y)
LOCATIONS = {
    # Sectors
    'F-6 Markaz': (0, 0),
    'F-7 Markaz': (6, 3),
    'G-9 Markaz': (-5, 7),
    'I-8 Markaz': (-10, 13),
    'E-11 Markaz': (-7, -4),
    'F-10 Markaz': (3, 10),
    'G-11 Markaz': (-2, 10),
    'F-17': (10, 18),
    'E-11': (-6, -6),
    'G-10': (0, 10),
    'D-12': (-13, -2),
    'F-11': (5, 10),
    'G-6': (-3, 2),

    # Universities
    'IIUI': (-15, 15),
    'Air University': (7, 13),
    'FAST University': (2, 5),
    'COMSATS': (10, 7),
    'NUST': (-5, 14),

    # Landmarks
    'Faisal Mosque': (0, 13),
    'Shakarparian': (7, -2),
    'Pakistan Monument': (5, -5),
    'Daman-e-Koh': (2, 15),
    'Centaurus Mall': (5, 0),
    'Serena Hotel': (2, 2)
}


# Dictionary of direct distances between connected locations
DISTANCES = {
    # Major connections between sectors
    ('F-6 Markaz', 'F-7 Markaz'): 3,
    ('F-7 Markaz', 'F-10 Markaz'): 4,
    ('F-10 Markaz', 'F-11'): 2,
    ('G-9 Markaz', 'G-10'): 2,
    ('G-10', 'G-11 Markaz'): 3,
    ('E-11 Markaz', 'E-11'): 1,
    ('I-8 Markaz', 'G-9 Markaz'): 5,

    # Connections to universities
    ('F-7 Markaz', 'FAST University'): 3,
    ('G-11 Markaz', 'NUST'): 4,
    ('F-10 Markaz', 'Air University'): 4,
    ('G-9 Markaz', 'COMSATS'): 6,
    ('E-11', 'IIUI'): 8,

    # Connections to landmarks
    ('F-7 Markaz', 'Centaurus Mall'): 2,
    ('F-6 Markaz', 'Serena Hotel'): 2,
    ('G-10', 'Faisal Mosque'): 3,
    ('F-11', 'Daman-e-Koh'): 4,
    ('F-7 Markaz', 'Pakistan Monument'): 4,
    ('F-6 Markaz', 'Shakarparian'): 5,

    # Additional strategic connections
    ('G-6', 'F-6 Markaz'): 2,
    ('G-6', 'G-9 Markaz'): 4,
    ('F-10 Markaz', 'G-10'): 2,
    ('F-11', 'E-11'): 5,
    ('D-12', 'E-11'): 3,
    ('F-17', 'Air University'): 4
}

# Dynamically calculate scaling factor to fit within bounds
def calculate_scaling_factor(locations, target_range=10):
    x_vals = [x for x, y in locations.values()]
    y_vals = [y for x, y in locations.values()]
    x_range = max(x_vals) - min(x_vals)
    y_range = max(y_vals) - min(y_vals)
    max_range = max(x_range, y_range)
    return target_range / max_range if max_range != 0 else 1

SCALING_FACTOR = calculate_scaling_factor(LOCATIONS, target_range=10)

# Scale locations
def scale_locations(locations, factor):
    return {loc: (x * factor, y * factor) for loc, (x, y) in locations.items()}

LOCATIONS = scale_locations(LOCATIONS, SCALING_FACTOR)'''
import matplotlib.pyplot as plt
import numpy as np


# Updated dictionary of locations with unique coordinates
LOCATIONS = {
    'F-6 Markaz': (0, 0),
    'F-7 Markaz': (2, 1),
    'G-9 Markaz': (-2, 3.5),
    'I-8 Markaz': (-3, 5),
    'E-11 Markaz': (-3, -2),
    'F-10 Markaz': (1, 3),
    'G-11 Markaz': (-1, 4),
    'F-17': (5, 7),
    'E-11': (-3, -3),
    'G-10': (0, 4),
    'D-12': (-5, -1),
    'F-11': (2, 4),
    'G-6': (-1, 1),
    'IIUI': (-6, 6),
    'Air University': (3, 5),
    'FAST University': (1, 2),
    'COMSATS': (4, 3),
    'NUST': (-2, 6),
    'Faisal Mosque': (0, 6),
    'Shakarparian': (3, -1),
    'Pakistan Monument': (2, -2),
    'Daman-e-Koh': (1, 6),
    'Centaurus Mall': (2, 0),
    'Serena Hotel': (1, 1),
    # Added Hospitals (unique locations)
    'PIMS Hospital': (-1, 2.7),
    'Shifa Hospital': (-3, 6.5),
    'Ali Medical Hospital': (3.5, 2),
    # Added Fire Stations (unique locations)
    'Fire Station F-7': (2.5, 0.5),
    'Fire Station G-9': (-2.5, 2.5),
    'Fire Station I-8': (-4.5, 4.5)
}

# Updated distances with multiple connections for hospitals and fire stations
DISTANCES = {
    ('F-6 Markaz', 'F-7 Markaz'): 3,
    ('F-7 Markaz', 'F-10 Markaz'): 4,
    ('F-10 Markaz', 'F-11'): 2,
    ('G-9 Markaz', 'G-10'): 2,
    ('G-10', 'G-11 Markaz'): 3,
    ('E-11 Markaz', 'E-11'): 1,
    ('I-8 Markaz', 'G-9 Markaz'): 5,
    ('F-7 Markaz', 'FAST University'): 3,
    ('G-11 Markaz', 'NUST'): 4,
    ('F-10 Markaz', 'Air University'): 4,
    ('G-9 Markaz', 'COMSATS'): 6,
    ('E-11', 'IIUI'): 8,
    ('F-7 Markaz', 'Centaurus Mall'): 2,
    ('F-6 Markaz', 'Serena Hotel'): 2,
    ('G-10', 'Faisal Mosque'): 3,
    ('F-11', 'Daman-e-Koh'): 4,
    ('F-7 Markaz', 'Pakistan Monument'): 4,
    ('F-6 Markaz', 'Shakarparian'): 5,
    ('G-6', 'F-6 Markaz'): 2,
    ('G-6', 'G-9 Markaz'): 4,
    ('F-10 Markaz', 'G-10'): 2,
    ('F-11', 'E-11'): 5,
    ('D-12', 'E-11'): 3,
    ('F-17', 'Air University'): 4,
    # Connections for hospitals
    ('PIMS Hospital', 'G-9 Markaz'): 2,
    ('PIMS Hospital', 'G-10'): 2,
    ('PIMS Hospital', 'Faisal Mosque'): 3,
    ('Shifa Hospital', 'NUST'): 3,
    ('Shifa Hospital', 'G-11 Markaz'): 2,
    ('Shifa Hospital', 'I-8 Markaz'): 6,
    ('Ali Medical Hospital', 'FAST University'): 2,
    ('Ali Medical Hospital', 'Air University'): 2,
    ('Ali Medical Hospital', 'COMSATS'): 3,
    # Connections for fire stations
    ('Fire Station F-7', 'F-7 Markaz'): 1,
    ('Fire Station F-7', 'Centaurus Mall'): 2,
    ('Fire Station F-7', 'Pakistan Monument'): 3,
    ('Fire Station G-9', 'G-9 Markaz'): 1,
    ('Fire Station G-9', 'G-10'): 2,
    ('Fire Station G-9', 'G-6'): 2,
    ('Fire Station I-8', 'I-8 Markaz'): 1,
    ('Fire Station I-8', 'Shifa Hospital'): 2,
    ('Fire Station I-8', 'G-9 Markaz'): 5
}

# Dynamically calculate scaling factor to fit within bounds
def calculate_scaling_factor(locations, target_range=10, min_spacing=2):
    x_vals = [x for x, y in locations.values()]
    y_vals = [y for x, y in locations.values()]
    x_range = max(x_vals) - min(x_vals)
    y_range = max(y_vals) - min(y_vals)
    max_range = max(x_range, y_range)
    
    # Apply non-linear scaling for more separation
    scaling_factor = target_range / max_range if max_range != 0 else 1
    return scaling_factor + min_spacing / max_range

SCALING_FACTOR = calculate_scaling_factor(LOCATIONS, target_range=10)

# Scale locations
def scale_locations(locations, factor):
    return {loc: (x * factor, y * factor) for loc, (x, y) in locations.items()}

LOCATIONS = scale_locations(LOCATIONS, SCALING_FACTOR)

# Plot the map
'''def plot_map(locations, distances):
    plt.figure(figsize=(12, 12))

    for loc, (x, y) in locations.items():
        # Differentiate types of locations
        if 'Hospital' in loc:
            plt.scatter(x, y, color='red', label='Hospital' if 'Hospital' not in plt.gca().get_legend_handles_labels()[1] else "", s=200, alpha=0.7)
        elif 'Fire Station' in loc:
            plt.scatter(x, y, color='orange', label='Fire Station' if 'Fire Station' not in plt.gca().get_legend_handles_labels()[1] else "", s=200, alpha=0.7)
        else:
            plt.scatter(x, y, color='blue', label='Location' if 'Location' not in plt.gca().get_legend_handles_labels()[1] else "", s=200, alpha=0.5)
        plt.text(x + 0.3, y + 0.3, loc, fontsize=8)

    for (loc1, loc2), dist in distances.items():
        x1, y1 = locations[loc1]
        x2, y2 = locations[loc2]
        plt.plot([x1, x2], [y1, y2], 'k-', linewidth=1.5)
        plt.text((x1 + x2) / 2, (y1 + y2) / 2, f'{dist}', fontsize=8, color='blue')

    plt.title('Map of Locations, Hospitals, and Fire Stations')
    plt.xlabel('X Coordinate')
    plt.ylabel('Y Coordinate')
    plt.grid(True)
    plt.legend()
    plt.show()

plot_map(LOCATIONS, DISTANCES)'''

def visualize_map(self, highlight_path=None):
    """
    Visualize the map with locations, distances, and optionally highlight a path.
    """
    plt.figure(figsize=(12, 12))

    for loc, (x, y) in LOCATIONS.items():
        # Differentiate types of locations
        if 'Hospital' in loc:
            plt.scatter(x, y, color='red', label='Hospital' if 'Hospital' not in plt.gca().get_legend_handles_labels()[1] else "", s=200, alpha=0.7)
        elif 'Fire Station' in loc:
            plt.scatter(x, y, color='orange', label='Fire Station' if 'Fire Station' not in plt.gca().get_legend_handles_labels()[1] else "", s=200, alpha=0.7)
        else:
            plt.scatter(x, y, color='blue', label='Location' if 'Location' not in plt.gca().get_legend_handles_labels()[1] else "", s=200, alpha=0.5)
        plt.text(x + 0.3, y + 0.3, loc, fontsize=8)

    for (loc1, loc2), dist in DISTANCES.items():
        x1, y1 = LOCATIONS[loc1]
        x2, y2 = LOCATIONS[loc2]
        plt.plot([x1, x2], [y1, y2], 'k-', linewidth=1.5)
        plt.text((x1 + x2) / 2, (y1 + y2) / 2, f'{dist}', fontsize=8, color='blue')
    if highlight_path:
        path_edges = list(zip(highlight_path[:-1], highlight_path[1:]))
        for loc1, loc2 in path_edges:
            x1, y1 = LOCATIONS[loc1]
            x2, y2 = LOCATIONS[loc2]
            plt.plot([x1, x2], [y1, y2], 'r-', linewidth=2)  # Highlight path in red

    plt.title('Map of Locations, Hospitals, and Fire Stations')
    plt.xlabel('X Coordinate')
    plt.ylabel('Y Coordinate')
    plt.grid(True)
    plt.legend()
    plt.show()


class IslamabadMap:
    def __init__(self, file_path='map_data.json'):
        self.file_path = file_path
        self.graph = load_data_from_file(self.file_path, Graph) or self._initialize_map()
        self.locations = LOCATIONS  # Dictionary of locations and their coordinates
        self.distances = DISTANCES  # Dictionary of distances between locations
        self.visualize_map = visualize_map

    def _initialize_map(self):
        """Initialize the map graph with locations and distances."""
        graph = Graph()
        for location in LOCATIONS:
            graph.add_node(location)
        for (start, end), distance in DISTANCES.items():
            graph.add_edge(start, end, distance)
            graph.add_edge(end, start, distance)  # Add reverse direction
        #save_data_to_file(self.file_path, graph)
        return graph

    def get_location_coordinates(self, location):
        """Get the coordinates of a specific location."""
        return LOCATIONS.get(location)

    def get_direct_distance(self, start, end):
        """Get the direct distance between two locations if they're directly connected."""
        return DISTANCES.get((start, end)) or DISTANCES.get((end, start))

    def get_shortest_path(self, start, end):
            """Delegate shortest path calculation to the graph."""
            return self.graph.get_shortest_path(start, end)


    def get_nearby_locations(self, location, max_distance):
        """Get all locations within a specified distance of a given location."""
        if location not in LOCATIONS:
            return []
        distances, _ = self.graph.dijkstra(location)
        return [loc for loc, dist in distances.items() if 0 < dist <= max_distance]

    def get_all_locations(self):
        """Return a list of all locations in the map."""
        return list(LOCATIONS.keys())

    def get_location_type(self, location):
        """Return the type of location (Sector, University, or Landmark)."""
        if location not in LOCATIONS:
            return None
        if 'University' in location or 'NUST' in location or 'IIUI' in location or 'COMSATS' in location:
            return 'University'
        if any(sector in location for sector in ['F-', 'G-', 'I-', 'E-', 'D-']):
            return 'Sector'
        return 'Landmark'

    def get_distances(self):
        """Return all distances between connected locations."""
        return self.distances

    def visualize_ride_path(self, start, end):
        """
        Visualize the shortest path between two locations on the map.
        """
        print(f"Debug - Visualization starting with: start={start}, end={end}")

        # First ensure we have a graph
        if not hasattr(self, 'graph') or not self.graph.nodes:
            print("Debug: Graph not initialized or empty, initializing now...")
            self.graph = self._initialize_map()  # Assuming this is your initialization method

        # Verify nodes exist in graph
        if start not in self.graph.nodes:
            print(f"Debug: Start node '{start}' not found in graph nodes: {list(self.graph.nodes)}")
            return
        if end not in self.graph.nodes:
            print(f"Debug: End node '{end}' not found in graph nodes: {list(self.graph.nodes)}")
            return

        # Get the shortest path
        path = self.graph.get_shortest_path(start, end)
        if not path:
            print(f"No path found between {start} and {end}")
            return

        # Debugging: Print the path
        print(f"Debug - Shortest path found: {path}")

        # Reuse the visualize_map function with path highlighting
        visualize_map(self, highlight_path=path)


# Helper functions for the map
def is_valid_location(location):
    """Check if a location exists in the map."""
    return location in LOCATIONS

def get_distance_matrix():
    """Generate a complete distance matrix between all locations."""
    map_instance = IslamabadMap()
    locations = list(LOCATIONS.keys())
    matrix = {}

    for start in locations:
        matrix[start] = {}
        distances, _ = map_instance.graph.dijkstra(start)
        for end in locations:
            matrix[start][end] = distances.get(end, float('inf'))

    return matrix

import networkx as nx
import matplotlib.pyplot as plt
import plotly.graph_objects as go

# Updated dictionary of locations with unique coordinates
LOCATIONS = {
    'F-6 Markaz': (0, 0),
    'F-7 Markaz': (2, 1),
    'G-9 Markaz': (-2, 3.5),
    'I-8 Markaz': (-3, 5),
    'E-11 Markaz': (-3, -2),
    'F-10 Markaz': (1, 3),
    'G-11 Markaz': (-1, 4),
    'F-17': (5, 7),
    'E-11': (-3, -3),
    'G-10': (0, 4),
    'D-12': (-5, -1),
    'F-11': (2, 4),
    'G-6': (-1, 1),
    'IIUI': (-6, 6),
    'Air University': (3, 5),
    'FAST University': (1, 2),
    'COMSATS': (4, 3),
    'NUST': (-2, 6),
    'Faisal Mosque': (0, 6),
    'Shakarparian': (3, -1),
    'Pakistan Monument': (2, -2),
    'Daman-e-Koh': (1, 6),
    'Centaurus Mall': (2, 0),
    'Serena Hotel': (1, 1),
    # Added Hospitals (unique locations)
    'PIMS Hospital': (-1, 2.7),
    'Shifa Hospital': (-3, 6.5),
    'Ali Medical Hospital': (3.5, 2),
    # Added Fire Stations (unique locations)
    'Fire Station F-7': (2.5, 0.5),
    'Fire Station G-9': (-2.5, 2.5),
    'Fire Station I-8': (-4.5, 4.5)
}

# Updated distances with multiple connections for hospitals and fire stations
DISTANCES = {
    ('F-6 Markaz', 'F-7 Markaz'): 3,
    ('F-7 Markaz', 'F-10 Markaz'): 4,
    ('F-10 Markaz', 'F-11'): 2,
    ('G-9 Markaz', 'G-10'): 2,
    ('G-10', 'G-11 Markaz'): 3,
    ('E-11 Markaz', 'E-11'): 1,
    ('I-8 Markaz', 'G-9 Markaz'): 5,
    ('F-7 Markaz', 'FAST University'): 3,
    ('G-11 Markaz', 'NUST'): 4,
    ('F-10 Markaz', 'Air University'): 4,
    ('G-9 Markaz', 'COMSATS'): 6,
    ('E-11', 'IIUI'): 8,
    ('F-7 Markaz', 'Centaurus Mall'): 2,
    ('F-6 Markaz', 'Serena Hotel'): 2,
    ('G-10', 'Faisal Mosque'): 3,
    ('F-11', 'Daman-e-Koh'): 4,
    ('F-7 Markaz', 'Pakistan Monument'): 4,
    ('F-6 Markaz', 'Shakarparian'): 5,
    ('G-6', 'F-6 Markaz'): 2,
    ('G-6', 'G-9 Markaz'): 4,
    ('F-10 Markaz', 'G-10'): 2,
    ('F-11', 'E-11'): 5,
    ('D-12', 'E-11'): 3,
    ('F-17', 'Air University'): 4,
    # Connections for hospitals
    ('PIMS Hospital', 'G-9 Markaz'): 2,
    ('PIMS Hospital', 'G-10'): 2,
    ('PIMS Hospital', 'Faisal Mosque'): 3,
    ('Shifa Hospital', 'NUST'): 3,
    ('Shifa Hospital', 'G-11 Markaz'): 2,
    ('Shifa Hospital', 'I-8 Markaz'): 6,
    ('Ali Medical Hospital', 'FAST University'): 2,
    ('Ali Medical Hospital', 'Air University'): 2,
    ('Ali Medical Hospital', 'COMSATS'): 3,
    # Connections for fire stations
    ('Fire Station F-7', 'F-7 Markaz'): 1,
    ('Fire Station F-7', 'Centaurus Mall'): 2,
    ('Fire Station F-7', 'Pakistan Monument'): 3,
    ('Fire Station G-9', 'G-9 Markaz'): 1,
    ('Fire Station G-9', 'G-10'): 2,
    ('Fire Station G-9', 'G-6'): 2,
    ('Fire Station I-8', 'I-8 Markaz'): 1,
    ('Fire Station I-8', 'Shifa Hospital'): 2,
    ('Fire Station I-8', 'G-9 Markaz'): 5
}



# Then modify the visualize_map function in map_visualization.py
'''def visualize_map(location_service):
    """
    Visualizes the map using the graph data from the location service.
    """
    G = nx.Graph()

    # Add nodes
    locations = location_service.map_data.get_all_locations()
    for location in locations:
        G.add_node(location)

    # Add edges with weights from DISTANCES dictionary
    distances = location_service.map_data.get_distances()
    for (start, end), distance in distances.items():
        G.add_edge(start, end, weight=distance)

    # Visualization
    pos = nx.spring_layout(G)
    plt.figure(figsize=(12, 8))
    plt.gca().set_facecolor('black')

    nx.draw(
        G, pos,
        with_labels=True,
        node_color='lightgrey',
        edge_color='red',
        font_color='white',
        node_size=2000,
        font_size=8,
        font_weight='bold'
    )

    # Draw edge labels
    edge_labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='white')

    plt.title("Islamabad Ride-Hailing Map", color='white', fontsize=14, pad=20)
    plt.show()'''

'''def visualize_map(location_service):
    """
    Visualizes the map using a grid layout based on location coordinates.
    """
    G = nx.Graph()

    # Add nodes with coordinates
    locations = location_service.map_data.get_all_locations()
    coordinates = location_service.map_data.locations
    for location in locations:
        G.add_node(location, pos=coordinates[location])

    # Add edges with weights from DISTANCES dictionary
    distances = location_service.map_data.get_distances()
    for (start, end), distance in distances.items():
        G.add_edge(start, end, weight=distance)

    # Extract positions for visualization
    pos = nx.get_node_attributes(G, 'pos')

    # Visualization
    plt.figure(figsize=(12, 12))
    plt.gca().set_facecolor('white')

    # Draw nodes
    nx.draw_networkx_nodes(G, pos, node_color='skyblue', node_size=1200)

    # Draw edges
    nx.draw_networkx_edges(G, pos, edge_color='gray', width=2)

    # Draw node labels
    nx.draw_networkx_labels(G, pos, font_size=10, font_weight='bold')

    # Draw edge labels (distances)
    edge_labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=8)

    plt.title("Islamabad City Map - Grid Layout", fontsize=16, pad=20)
    plt.show()'''

'''def visualize_map(location_service):
    """
    Visualizes the map with nodes placed on a grid where x and y intersect.
    Distances are scaled for better separation, and edges follow the grid lines.
    """
    G = nx.Graph()

    # Add nodes with positions based on their coordinates
    locations = location_service.map_data.get_all_locations()
    coordinates = location_service.map_data.locations

    # Scaling factor to visually separate nodes
    scale = 100  # Adjust this as needed for better visualization

    for location, (x, y) in coordinates.items():
        G.add_node(location, pos=(x * scale, y * scale))

    # Add edges with weights
    distances = location_service.map_data.get_distances()
    for (start, end), distance in distances.items():
        G.add_edge(start, end, weight=distance)

    # Extract positions for visualization
    pos = nx.get_node_attributes(G, 'pos')

    # Adjust edge positions to follow the grid
    def snap_to_grid(x, y, grid_size=scale):
        """Snap coordinates to the nearest grid line."""
        return (round(x / grid_size) * grid_size, round(y / grid_size) * grid_size)

    # Visualization
    plt.figure(figsize=(12, 12))
    plt.gca().set_facecolor('white')

    # Draw nodes
    nx.draw_networkx_nodes(G, pos, node_color='skyblue', node_size=800)

    # Draw edges
    edge_positions = []
    for start, end in G.edges():
        x_start, y_start = pos[start]
        x_end, y_end = pos[end]
        edge_positions.append(((x_start, y_start), (x_end, y_end)))

    # Snap edge positions to grid
    edge_positions = [(snap_to_grid(x1, y1), snap_to_grid(x2, y2)) for (x1, y1), (x2, y2) in edge_positions]

    # Draw edges with adjusted positions
    for (x1, y1), (x2, y2) in edge_positions:
        plt.plot([x1, x2], [y1, y2], color='gray', linewidth=2)

    # Draw node labels
    nx.draw_networkx_labels(G, pos, font_size=8, font_weight='bold')

    # Draw edge labels (distances)
    edge_labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=6)

    # Add grid lines for better visualization
    x_min = min(x for x, y in coordinates.values()) * scale - scale
    x_max = max(x for x, y in coordinates.values()) * scale + scale
    y_min = min(y for x, y in coordinates.values()) * scale - scale
    y_max = max(y for x, y in coordinates.values()) * scale + scale

    for i in range(int(x_min), int(x_max) + scale, scale):
        plt.axvline(i, color='lightgray', linewidth=0.5, zorder=0)
    for i in range(int(y_min), int(y_max) + scale, scale):
        plt.axhline(i, color='lightgray', linewidth=0.5, zorder=0)

    plt.xticks(range(int(x_min), int(x_max) + scale, scale), [])
    plt.yticks(range(int(y_min), int(y_max) + scale, scale), [])
    plt.title("Islamabad City Map - Grid Intersection Layout", fontsize=16, pad=20)
    plt.gca().invert_yaxis()  # Optional: Invert y-axis for better alignment
    plt.show()'''




'''def visualize_map(location_service, scale=100):
    G = nx.Graph()

    # Scale up coordinates for better spacing
    for location, (x, y) in location_service.map_data.locations.items():
        G.add_node(location)
        G.nodes[location]['pos'] = (x * scale, y * scale)

    pos = nx.get_node_attributes(G, 'pos')

    if not pos:
        print("No locations to visualize.")
        return

    plt.figure(figsize=(20, 20))  # Increase figure size
    plt.gca().set_facecolor('white')

    # Grid lines for visual reference
    x_coords = [x for x, y in pos.values()]
    y_coords = [y for x, y in pos.values()]
    x_min, x_max = min(x_coords) - scale, max(x_coords) + scale
    y_min, y_max = min(y_coords) - scale, max(y_coords) + scale

    for x in range(int(x_min), int(x_max) + scale, scale):
        plt.axvline(x, color='lightgray', linewidth=0.5, zorder=0)
    for y in range(int(y_min), int(y_max) + scale, scale):
        plt.axhline(y, color='lightgray', linewidth=0.5, zorder=0)

    # Draw orthogonal edges
    for (start, end) in location_service.map_data.get_distances().keys():
        start_pos = pos[start]
        end_pos = pos[end]
        mid_point = (end_pos[0], start_pos[1])

        plt.plot([start_pos[0], mid_point[0]], [start_pos[1], mid_point[1]], 'gray', linewidth=2)
        plt.plot([mid_point[0], end_pos[0]], [mid_point[1], end_pos[1]], 'gray', linewidth=2)

    nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=900, alpha=0.8)
    nx.draw_networkx_labels(G, pos, font_size=10, font_weight='bold')

    plt.title("Islamabad City Map - Expanded Layout", fontsize=18)
    plt.axis('equal')
    plt.show()'''

'''def visualize_map(location_service, scale=100):
    locations = location_service.map_data.locations
    distances = location_service.map_data.get_distances()

    # Scale up coordinates for better spacing
    scaled_locations = {loc: (x * scale, y * scale) for loc, (x, y) in locations.items()}

    plt.figure(figsize=(12, 12))  # Set figure size

    # Plot nodes
    for loc, (x, y) in scaled_locations.items():
        plt.scatter(x, y, label=loc, s=200, alpha=0.5)
        plt.text(x + 0.3, y + 0.3, loc, fontsize=8)  # Label nodes

    # Plot edges with distances
    for (loc1, loc2), dist in distances.items():
        x1, y1 = scaled_locations[loc1]
        x2, y2 = scaled_locations[loc2]
        plt.plot([x1, x2], [y1, y2], 'k-', linewidth=1.5)  # Draw edge
        plt.text((x1 + x2) / 2, (y1 + y2) / 2, f'{dist}', fontsize=8, color='blue')  # Label edge

    plt.title('Map of Locations and Connections', fontsize=16)
    plt.xlabel('X Coordinate')
    plt.ylabel('Y Coordinate')
    plt.grid(True)
    plt.legend()
    plt.show()

    import plotly.graph_objects as go'''

import plotly.graph_objects as go

'''def visualize_map(location_service, scale=100):
    # Scale up coordinates for better spacing
    locations = location_service.map_data.locations
    distances = location_service.map_data.get_distances()
    scaled_locations = {loc: (x * scale, y * scale) for loc, (x, y) in locations.items()}

    # Create figure
    fig = go.Figure()

    # Add edges to the figure
    for (loc1, loc2), dist in distances.items():
        x1, y1 = scaled_locations[loc1]
        x2, y2 = scaled_locations[loc2]
        fig.add_trace(go.Scatter(
            x=[x1, x2],
            y=[y1, y2],
            mode='lines',
            line=dict(width=1.5, color='gray'),
            hoverinfo='none'
        ))

    # Add nodes to the figure
    node_x = []
    node_y = []
    node_text = []

    for loc, (x, y) in scaled_locations.items():
        node_x.append(x)
        node_y.append(y)
        node_text.append(loc)

    fig.add_trace(go.Scatter(
        x=node_x,
        y=node_y,
        mode='markers+text',
        text=node_text,
        textposition='top center',
        marker=dict(size=10, color='blue', opacity=0.8),
        hoverinfo='text'
    ))

    # Layout adjustments
    fig.update_layout(
        title='Interactive Map of Locations and Connections',
        xaxis=dict(title='X Coordinate', showgrid=True, zeroline=False),
        yaxis=dict(title='Y Coordinate', showgrid=True, zeroline=False),
        showlegend=False,
        autosize=True,  # Automatically adjust to the browser window
        plot_bgcolor='white',
        margin=dict(l=0, r=0, t=30, b=0)  # Minimize margins for full-screen effect
    )

    fig.show()'''



def visualize_map(self, highlight_path=None):
    """
    Visualize the map with locations, distances, and optionally highlight a path.
    """
    plt.figure(figsize=(12, 12))

    for loc, (x, y) in LOCATIONS.items():
        # Differentiate types of locations
        if 'Hospital' in loc:
            plt.scatter(x, y, color='red', label='Hospital' if 'Hospital' not in plt.gca().get_legend_handles_labels()[1] else "", s=200, alpha=0.7)
        elif 'Fire Station' in loc:
            plt.scatter(x, y, color='orange', label='Fire Station' if 'Fire Station' not in plt.gca().get_legend_handles_labels()[1] else "", s=200, alpha=0.7)
        else:
            plt.scatter(x, y, color='blue', label='Location' if 'Location' not in plt.gca().get_legend_handles_labels()[1] else "", s=200, alpha=0.5)
        plt.text(x + 0.3, y + 0.3, loc, fontsize=8)

    for (loc1, loc2), dist in DISTANCES.items():
        x1, y1 = LOCATIONS[loc1]
        x2, y2 = LOCATIONS[loc2]
        plt.plot([x1, x2], [y1, y2], 'k-', linewidth=1.5)
        plt.text((x1 + x2) / 2, (y1 + y2) / 2, f'{dist}', fontsize=8, color='blue')
    if highlight_path:
        path_edges = list(zip(highlight_path[:-1], highlight_path[1:]))
        for loc1, loc2 in path_edges:
            x1, y1 = LOCATIONS[loc1]
            x2, y2 = LOCATIONS[loc2]
            plt.plot([x1, x2], [y1, y2], 'r-', linewidth=2)  # Highlight path in red

    plt.title('Map of Locations, Hospitals, and Fire Stations')
    plt.xlabel('X Coordinate')
    plt.ylabel('Y Coordinate')
    plt.grid(True)
    plt.legend()
    plt.show()



'''def visualize_ride_path(self, start, end):
    """
    Visualize the shortest path between two locations on the map.
    
    Args:
        start (str): Starting location name
        end (str): Ending location name
    """
    if not self.graph:
        print("Error: Graph not initialized")
        return
        
    # Get the shortest path
    path = self.graph.get_shortest_path(start, end)
    if not path:
        print(f"No path found between {start} and {end}")
        return
        
    # Create a new networkx graph for visualization
    G = nx.Graph()
    
    # Add all nodes and edges
    for node in self.graph.nodes:
        G.add_node(node)
    for node in self.graph.nodes:
        for neighbor, weight in self.graph.nodes[node].items():
            G.add_edge(node, neighbor, weight=weight)
    
    # Draw the graph
    pos = nx.spring_layout(G)
    plt.figure(figsize=(12, 8))
    
    # Draw all edges in light gray
    nx.draw_networkx_edges(G, pos, edge_color='lightgray', width=1)
    
    # Draw all nodes in light blue
    nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=500)
    
    # Highlight the path
    path_edges = list(zip(path[:-1], path[1:]))
    nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='r', width=2)
    
    # Highlight start and end nodes
    nx.draw_networkx_nodes(G, pos, nodelist=[start], node_color='g', node_size=500)
    nx.draw_networkx_nodes(G, pos, nodelist=[end], node_color='r', node_size=500)
    
    # Add labels
    nx.draw_networkx_labels(G, pos)
    
    plt.title(f"Shortest Path from {start} to {end}")
    plt.axis('off')
    plt.show()'''import os
import time
import sys
import hashlib
from data_structures import HashTable
from user_management import UserManagement
from driver_management import DriverManagement
from save_load import load_data_from_file
from data_structures import HashTable
from map_data import IslamabadMap

sys.path.append(os.path.dirname(os.path.abspath(__file__)))
islamabad_map = IslamabadMap()
user_mgmt = UserManagement(islamabad_map)
driver_mgmt = DriverManagement()
hash_table = HashTable()

def calculate_file_hash(filename):
    """Calculate the hash of a file."""
    try:
        with open(filename, 'rb') as f:
            file_content = f.read()
            file_hash = hashlib.sha256(file_content).hexdigest()
            return file_hash
    except FileNotFoundError:
        print(f"Debug: File {filename} not found.")
        return None

def poll_file(filename, callback, poll_interval=1):
    """
    Polls a file for changes and reloads it using a callback when modified.
    """
    last_hash = calculate_file_hash(filename)

    while True:
        time.sleep(poll_interval)  # Wait for the next poll cycle
        current_hash = calculate_file_hash(filename)

        if current_hash != last_hash:
            print(f"File {filename} has been updated. Reloading...")
            callback(filename)
            last_hash = current_hash

def reload_users(filename):
    global user_mgmt
    try:
        new_users = load_data_from_file(filename, HashTable)
        if isinstance(new_users, HashTable):
            user_mgmt.users = new_users
            print(f"User data reloaded from {filename}.")
        else:
            print(f"Warning: Loaded data is not a HashTable. Resetting to empty.")
            user_mgmt.users = HashTable()
    
    except Exception as e:
        print(f"An error occurred while reloading users: {e}")

def reload_drivers(filename):
    global driver_mgmt
    try:
        new_drivers = load_data_from_file(filename, HashTable)
        if isinstance(new_drivers, HashTable):
            driver_mgmt.drivers = new_drivers
            print(f"Driver data reloaded successfully from {filename}.")
        else:
            print(f"Warning: Loaded data is not a HashTable. Resetting to empty.")
            driver_mgmt.drivers = HashTable()
    
    except Exception as e:
        print(f"An error occurred while reloading drivers: {e}")


# pricing.py
from save_load import save_data_to_file, load_data_from_file

class Pricing:
    def __init__(self, base_rate=10, per_km_rate=5, rideshare_discount=0.2, surge_multiplier=1.0, file_path='pricing.json'):
        self.file_path = file_path
        data = load_data_from_file(self.file_path, dict) or {}
        self.base_rate = data.get('base_rate', base_rate)
        self.per_km_rate = data.get('per_km_rate', per_km_rate)
        self.rideshare_discount = data.get('rideshare_discount', rideshare_discount)
        self.surge_multiplier = data.get('surge_multiplier', surge_multiplier)

    def save_to_file(self):
        data = {
            'base_rate': self.base_rate,
            'per_km_rate': self.per_km_rate,
            'rideshare_discount': self.rideshare_discount,
            'surge_multiplier': self.surge_multiplier,
        }
        save_data_to_file(data, self.file_path)

    
    def calculate_fare(self, distance, is_rideshare=False, is_peak_time=False):
        """
        Calculates the fare for a given distance, with options for ridesharing and peak time pricing.
        """
        fare = self.base_rate + (distance * self.per_km_rate)
        if is_rideshare:
            fare *= (1 - self.rideshare_discount)
        if is_peak_time:
            fare *= self.surge_multiplier
        return round(fare, 2)

    def split_fare(self, total_fare, num_passengers):
        """
        Splits the fare among rideshare participants.
        """
        if num_passengers <= 0:
            return total_fare
        return round(total_fare / num_passengers, 2)from save_load  import save_data_to_file, load_data_from_file

class RatingSystem:
    def __init__(self, driver_management):
        self.driver_mgmt = driver_management

    def post_ride_feedback(self, driver_id, ride_id, rating, feedback=""):
        if rating < 1 or rating > 5:
            return False, "Rating must be between 1 and 5"

        driver = self.driver_mgmt.get_driver_by_id(driver_id)
        if not driver:
            return False, "Driver not found"

        # Update driver's rating
        total_ratings = driver['total_ratings']
        current_rating = driver['rating']

        new_total = total_ratings + 1
        new_rating = ((current_rating * total_ratings) + rating) / new_total

        driver['rating'] = round(new_rating, 2)
        driver['total_ratings'] = new_total

        # Add feedback
        if 'feedback' not in driver:
            driver['feedback'] = []
        driver['feedback'].append({
            'ride_id': ride_id,
            'rating': rating,
            'feedback': feedback
        })

        # Save updated driver data
        self.driver_mgmt.drivers.insert(driver_id, driver)
        save_data_to_file(self.driver_mgmt, 'drivers_data.json')

        return True, "Feedback submitted successfully"
from data_structures import DoublyLinkedList, HashTable
from save_load import save_data_to_file, load_data_from_file

class RideHistory:
    def __init__(self, file_path='ride_history.json'):
        """
        Initializes the RideHistory with data loaded from a file if it exists.
        """
        self.file_path = file_path
        self.ride_history = load_data_from_file(self.file_path, DoublyLinkedList)

    def add_ride(self, ride_data):
        """
        Adds a ride record to the user's ride history and saves the updated history to the file.
        """
        self.ride_history.append(ride_data)
        save_data_to_file(self.ride_history, self.file_path)

    def get_ride_history(self):
        """
        Returns the list of all past rides in chronological order.
        """
        history = []
        current = self.ride_history.head
        while current:
            history.append(current.data)
            current = current.next
        return history
from data_structures import PriorityQueue, Queue, HashTable
from save_load import save_data_to_file, load_data_from_file
from rating_system import RatingSystem
import map_visualization
import time
import uuid

class RideRequest:
    def __init__(self, user_management, driver_management, location_service, pricing):  # Added missing dependencies
        self.user_mgmt = user_management
        self.driver_mgmt = driver_management
        self.location_service = location_service  # Added missing service
        self.pricing = pricing  # Added missing service
        self.rating_system = RatingSystem  # Store rating system instance
        self.map_visualization = map_visualization
        self.normal_requests = load_data_from_file('normal_requests.json', Queue) or Queue()  # Added fallback
        self.emergency_requests = load_data_from_file('emergency_requests.json', PriorityQueue) or PriorityQueue()
        self.active_rides = load_data_from_file('active_rides.json', HashTable) or HashTable()

    '''def request_ride(self, user_id, pickup_location, dropoff_location, is_emergency=False):
        user = self.user_mgmt.get_user_by_id(user_id)
        print("User Data in request_ride:", user)
        if not user or user['active_ride']:
            print("User Data:", user)
            return False, "Invalid user or user already has active ride"
        


        # Calculate distance and price
        distance = self.location_service.graph.get_shortest_path_distance(pickup_location, dropoff_location)
        if distance is None:
            print("Pickup:", pickup_location, "Destination:", dropoff_location)
            print("Graph Nodes:", self.location_service.graph.nodes)
            print("Graph Edges:", self.location_service.graph.nodes)

            return False, "Could not calculate route"

        price = self.pricing.calculate_fare(distance)

        request = {
            'id': str(uuid.uuid4()),
            'user_id': user_id,
            'pickup_location': pickup_location,
            'dropoff_location': dropoff_location,
            'status': 'pending',
            'timestamp': time.time(),
            'distance': distance,
            'price': price
        }

        if is_emergency:
            self.emergency_requests.push(1, request)
            save_data_to_file(self.emergency_requests, 'emergency_requests.json')
        else:
            self.normal_requests.enqueue(request)
            print("Enqueued Request:", request)
            save_data_to_file(self.normal_requests, 'normal_requests.json')

        return True, request'''
        
    '''def request_ride(self, user_id, pickup_location, dropoff_location, is_emergency=False):
        user = self.user_mgmt.get_user_by_id(user_id)
        if not user or user['active_ride']:
            return False, "Invalid user or user already has active ride"
        
        # Force graph initialization if empty
        if not self.location_service.graph.nodes:
            print("Graph is empty. Reinitializing map...")
            self.location_service.graph = self.location_service._initialize_map()

        # Calculate distance and price
        distance = self.location_service.graph.get_shortest_path_distance(pickup_location, dropoff_location)
        if distance is None:
            return False, "Could not calculate route"

        price = self.pricing.calculate_fare(distance)
        request = {
            'id': str(uuid.uuid4()),
            'user_id': user_id,
            'pickup_location': pickup_location,
            'dropoff_location': dropoff_location,
            'status': 'pending',
            'timestamp': time.time(),
            'distance': distance,
            'price': price
        }

        if is_emergency:
            self.emergency_requests.push(distance, request)
            save_data_to_file(self.emergency_requests, 'emergency_requests.json')
        else:
            self.normal_requests.enqueue(request)
            save_data_to_file(self.normal_requests, 'normal_requests.json')

        return True, request'''
    
    '''def request_ride(self, user_id, pickup_location, dropoff_location, is_emergency=False):
        user = self.user_mgmt.get_user_by_id(user_id)
        if not user or user['active_ride']:
            print(f"Debug: User validation failed. User data: {user}")
            return False, "Invalid user or user already has active ride"

        # Validate graph and locations
        if not self.location_service.graph.nodes:
            print("Debug: Graph is empty. Reinitializing...")
            self.location_service.graph = self.location_service._initialize_map()

        if pickup_location not in self.location_service.graph.nodes:
            print(f"Debug: Pickup location '{pickup_location}' not found in graph.")
            return False, "Invalid pickup location"

        if dropoff_location not in self.location_service.graph.nodes:
            print(f"Debug: Dropoff location '{dropoff_location}' not found in graph.")
            return False, "Invalid dropoff location"

        # Calculate distance and price
        distance = self.location_service.graph.get_shortest_path_distance(pickup_location, dropoff_location)
        if distance is None:
            print(f"Debug: No path found between '{pickup_location}' and '{dropoff_location}'.")
            return False, "Could not calculate route"

        price = self.pricing.calculate_fare(distance)
        print(f"Debug: Calculated price: {price}, Distance: {distance}")

        # Add request to queue
        request = {
            'id': str(uuid.uuid4()),
            'user_id': user_id,
            'pickup_location': pickup_location,
            'dropoff_location': dropoff_location,
            'status': 'pending',
            'timestamp': time.time(),
            'distance': distance,
            'price': price,
            'priority': 1 if is_emergency else 2,
            'type': 'emergency' if is_emergency else 'normal'
        }

        if is_emergency:
            self.emergency_requests.push(1, request)
            print(f"Debug: Emergency request added: {request}")
        else:
            self.normal_requests.enqueue(request)
            print(f"Debug: Normal request added: {request}")

        save_data_to_file(self.normal_requests, 'normal_requests.json')
            # Visualize the shortest path
        print("Debug: Visualizing shortest path...")
        try:
            self.map_visualization.visualize_ride_path(
            location_service=self.location_service,  # Location service
            start=pickup_location,                  # Pickup location (start)
            end=dropoff_location                    # Dropoff location (end)
        )
        except Exception as e:
            print(f"Error during visualization: {e}")
        return True, request'''
    

    def request_ride(self, user_id, pickup_location, dropoff_location, is_emergency=False):
        user = self.user_mgmt.get_user_by_id(user_id)
        
        # Check if the user has an active ride
        if not user or user['active_ride']:
            # Check if the active ride is not completed
            active_ride_id = user['active_ride']
            active_ride = self.active_rides.get(active_ride_id) if active_ride_id else None
            
            if active_ride and active_ride['status'] != 'completed':
                return False, "You have an active ride that is not completed. Please complete it before requesting another ride."

        # Validate graph and locations
        if not self.location_service.graph.nodes:
            print("Debug: Graph is empty. Reinitializing...")
            self.location_service.graph = self.location_service._initialize_map()

        if pickup_location not in self.location_service.graph.nodes:
            print(f"Debug: Pickup location '{pickup_location}' not found in graph.")
            return False, "Invalid pickup location"

        if dropoff_location not in self.location_service.graph.nodes:
            print(f"Debug: Dropoff location '{dropoff_location}' not found in graph.")
            return False, "Invalid dropoff location"

        # Calculate distance and price
        distance = self.location_service.graph.get_shortest_path_distance(pickup_location, dropoff_location)
        if distance is None:
            print(f"Debug: No path found between '{pickup_location}' and '{dropoff_location}'.")
            return False, "Could not calculate route"

        price = self.pricing.calculate_fare(distance)
        print(f"Debug: Calculated price: {price}, Distance: {distance}")

        # Add request to queue
        request = {
            'id': str(uuid.uuid4()),
            'user_id': user_id,
            'pickup_location': pickup_location,
            'dropoff_location': dropoff_location,
            'status': 'pending',
            'timestamp': time.time(),
            'distance': distance,
            'price': price,
            'priority': 1 if is_emergency else 2,
            'type': 'emergency' if is_emergency else 'normal'
        }

        if is_emergency:
            self.emergency_requests.push(1, request)
            print(f"Debug: Emergency request added: {request}")
        else:
            self.normal_requests.enqueue(request)
            print(f"Debug: Normal request added: {request}")

        save_data_to_file(self.normal_requests, 'normal_requests.json')
        
        # Visualize the shortest path
        print("Debug: Visualizing shortest path...")
        try:
            self.map_visualization.visualize_ride_path(
                location_service=self.location_service,  # Location service
                start=pickup_location,                  # Pickup location (start)
                end=dropoff_location                    # Dropoff location (end)
            )
        except Exception as e:
            print(f"Error during visualization: {e}")
        
        return True, request


    def _sync_driver_requests(self):
        """Sync ride requests to driver viewable file (ride_requests.json)."""
        save_data_to_file(self.normal_requests, 'ride_requests.json')


    '''def process_ride_requests(self):
        # Process emergency requests first
        while not self.emergency_requests.is_empty():
            request = self.emergency_requests.pop()
            save_data_to_file(self.emergency_requests, 'emergency_requests.json')
            driver = self._find_nearest_driver(request['pickup_location'])
            if driver:
                self._assign_ride(request, driver['id'])

        # Process normal requests
        while not self.normal_requests.is_empty():
            request = self.normal_requests.dequeue()
            save_data_to_file(self.normal_requests, 'normal_requests.json')
            driver = self._find_nearest_driver(request['pickup_location'])
            if driver:
                self._assign_ride(request, driver['id'])
            else:
                self.normal_requests.enqueue(request)
                save_data_to_file(self.normal_requests, 'normal_requests.json')'''
    
    def process_ride_requests(self):
        # Load ride requests from JSON
        ride_requests = load_data_from_file('ride_requests.json', list)  # Load as a list

        # Convert requests to a priority queue
        priority_queue = PriorityQueue()
        for request in ride_requests:
            priority_queue.push(request['priority'], request)

        # Process requests from the priority queue
        updated_requests = []
        while not priority_queue.is_empty():
            priority, request = priority_queue.pop()

            # Find the nearest driver
            driver = self._find_nearest_driver(request['pickup_location'])
            if driver:
                # Assign ride if a driver is found
                self._assign_ride(request, driver['id'])
            else:
                # Requeue the request if no driver is found
                updated_requests.append(request)

        # Save remaining requests back to the JSON file
        save_data_to_file(updated_requests, 'ride_requests.json')


    def _assign_ride(self, request, driver_id):
        ride_id = str(uuid.uuid4())
        ride_data = {
            'id': ride_id,
            'driver_id': driver_id,
            'status': 'assigned',
            'start_time': time.time()
        }

        # Add to active rides and save
        active_rides = load_data_from_file('active_rides.json', list)  # Load active rides as a list
        active_rides.append(ride_data)
        save_data_to_file(active_rides, 'active_rides.json')

        # Update user and driver statuses
        user = self.user_mgmt.get_user_by_id(request['user_id'])
        driver = self.driver_mgmt.get_driver_by_id(driver_id)

        user['active_ride'] = ride_id
        driver['active_ride'] = ride_id
        self.driver_mgmt.set_driver_availability(driver_id, False)

        return ride_id

    def complete_ride(self, ride_id):
        ride_data = self.active_rides.get(ride_id)
        if not ride_data:
            return False, "Ride not found"

        ride_data['status'] = 'completed'
        ride_data['end_time'] = time.time()
        ride_data['duration'] = ride_data['end_time'] - ride_data['start_time']

        user_id = ride_data['user_id']  # Assuming user_id is directly in ride_data
        driver_id = ride_data['driver_id']

        user = self.user_mgmt.get_user_by_id(user_id)
        driver = self.driver_mgmt.get_driver_by_id(driver_id)

        if user and driver:
            user['ride_history'].append(ride_data)
            driver['ride_history'].append(ride_data)

            user['active_ride'] = None
            driver['active_ride'] = None
            self.driver_mgmt.set_driver_availability(driver_id, True)

            self.active_rides.delete(ride_id)
            save_data_to_file(self.active_rides, 'active_rides.json')

            # Notify the user to provide feedback
            return True, f"Ride completed successfully. Please provide feedback for your ride ID: {ride_id}."
        
        return False, "Error updating user or driver profiles"
    def _find_nearest_driver(self, pickup_location):
        available_drivers = self.driver_mgmt.get_available_drivers()
        nearest_driver = None
        min_distance = float('inf')

        for driver in available_drivers:
            if driver['current_location']:
                distance = self._calculate_distance(pickup_location, driver['current_location'])
                if distance < min_distance:
                    min_distance = distance
                    nearest_driver = driver

        return nearest_driver


    def get_user_updates(self, user_id):
        user = self.user_mgmt.get_user_by_id(user_id)
        if not user or not user['active_ride']:
            return None

        ride_data = self.active_rides.get(user['active_ride'])
        if not ride_data:
            return None

        driver = self.driver_mgmt.get_driver_by_id(ride_data['driver_id'])
        if not driver:
            return None

        return {
            'type': 'ride_accepted',
            'ride_id': ride_data['id'],
            'driver': {
                'name': driver['name'],
                'phone': driver['phone'],
                'vehicle_type': driver['vehicle_type'],
                'current_location': driver['current_location']
            },
            'status': ride_data['status']
        }

    def get_driver_requests(self, current_location):
        if not self.normal_requests.queue:
            return []

        available_requests = []
        for request in self.normal_requests.queue:
            distance_to_pickup = self._calculate_distance(current_location, request['pickup_location'])
            ride_distance = self._calculate_distance(request['pickup_location'], request['dropoff_location'])
            fare = self._calculate_fare(ride_distance)

            request_data = {
                'id': request['id'],
                'pickup_location': request['pickup_location'],
                'dropoff_location': request['dropoff_location'],
                'distance': ride_distance,
                'distance_to_pickup': distance_to_pickup,
                'price': fare
            }
            available_requests.append(request_data)

        return available_requests
    

    def accept_ride(self, ride_request):
        # Logic to accept the ride
        ride_id = ride_request['id']
        driver_id = ride_request['driver_id']

        # Create the active ride data
        active_ride = {
            "id": ride_id,
            "user_id": ride_request['user_id'],
            "driver_id": driver_id,
            "pickup_location": ride_request['pickup_location'],
            "dropoff_location": ride_request['dropoff_location'],
            "status": "ongoing",
            "start_time": time.time()
        }

        # Load current active rides from the JSON file
        active_rides = load_data_from_file('active_rides.json', dict) or {}

        # Update the active rides dictionary with the new ride
        active_rides[ride_id] = active_ride  # Use ride_id as the key
        save_data_to_file(active_rides, 'active_rides.json')  # Save the updated active rides

        # Update the driver's active ride
        driver = self.driver_mgmt.get_driver_by_id(driver_id)
        print(driver_id)
        print(f"Debug: Retrieved driver before update: {driver}")  # Debug print
        if driver:
            driver['active_ride'] = ride_id  # Set the active ride ID
            self.driver_mgmt.update_driver(driver)  # Ensure you have a method to update the driver in your data store
            print(f"Debug: Updated driver after accepting ride: {driver}")  # Debug print
        else:
            print("Error: Driver not found.")

        return True, "Ride accepted successfully."
    
    def _calculate_distance(self, location1, location2):
        return self.location_service.get_distance_between(location1, location2) or 0

    def _calculate_fare(self, distance):
        return self.pricing.calculate_fare(distance)
import json
import os
import threading
from data_structures import DoublyLinkedList, HashTable

file_lock = threading.Lock()

# Custom encoder to handle non-serializable objects
class CustomJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        if hasattr(obj, 'to_dict'):
            return obj.to_dict()  # Convert objects with 'to_dict()' method
        if hasattr(obj, 'to_list'):
            return obj.to_list()  # Convert LinkedList to list
        return super().default(obj)  # Fallback for unsupported objects

# Universal save function
def save_data_to_file(data, filename):
    try:
        # Convert to serializable format
        if hasattr(data, 'to_dict'):
            data = data.to_dict()  # Convert HashTable or custom objects
        
        # Ensure keys are strings (tuples can't be serialized directly)
        if isinstance(data, dict):
            data = {str(k): v for k, v in data.items()}

        with file_lock:
            with open(filename, 'w') as f:
                json.dump(data, f, indent=4, cls=CustomJSONEncoder)
        
        print(f"Data successfully saved to {filename}")
        return True

    except TypeError as e:
        print(f"TypeError while saving {filename}: {e}")
    except Exception as e:
        print(f"Error saving to file {filename}: {e}")
    return False

# Universal load function with data type handling
def load_data_from_file(filename, data_type=dict):
    try:
        if not isinstance(filename, str):
            raise TypeError("Filename must be a string.")
        
        # Check if the file exists and is not empty
        if not os.path.exists(filename) or os.path.getsize(filename) == 0:
            print(f"File {filename} is empty or does not exist. Returning empty {data_type.__name__}.")
            return data_type()

        with open(filename, 'r') as f:
            data = json.load(f)

        # Convert to appropriate data structure
        if data_type == HashTable:
            if isinstance(data, dict):
                return HashTable.from_dict(data)
            else:
                print(f"Warning: Data from {filename} is not a dict. Initializing empty HashTable.")
                return HashTable()
        
        elif data_type == DoublyLinkedList:
            if isinstance(data, list):
                return DoublyLinkedList.from_list(data)
            else:
                print(f"Warning: Data from {filename} is not a list. Initializing empty DoublyLinkedList.")
                return DoublyLinkedList()

        return data  # Fallback for general dict/list cases

    except json.JSONDecodeError:
        print(f"JSON decode error in {filename}: File is likely empty or corrupted.")
        return data_type()  # Return an empty structure on error

    except Exception as e:
        print(f"Unexpected error loading {filename}: {e}")
        return data_type()
from data_structures import Graph
from save_load import save_data_to_file, load_data_from_file

class SocialRideshare:
    def __init__(self, file_path='user_connections.json'):
        """
        Initializes the SocialRideshare with user connections loaded from a file if it exists.
        """
        self.file_path = file_path
        self.user_connections = load_data_from_file(self.file_path, Graph)  # Load the graph from file

    def add_connection(self, user1, user2):
        """
        Establishes a connection between two users for potential ridesharing and saves the updated graph.
        """
        self.user_connections.add_node(user1)
        self.user_connections.add_node(user2)
        self.user_connections.add_edge(user1, user2, 1)  # Edge weight represents connection strength
        save_data_to_file(self.user_connections, self.file_path)  # Save the graph to file

    def find_rideshare_partners(self, user, pickup_location, dropoff_location):
        """
        Finds potential rideshare partners based on user connections and route similarity.
        """
        potential_partners = self.user_connections.get_neighbors(user)
        matches = []

        for partner in potential_partners:
            # Here you can add logic to match routes based on similarity (e.g., same path, close destinations).
            matches.append(partner)

        return matches
import threading
import time
import json

from polling import poll_file
from data_structures import HashTable

hash_table = HashTable()

# Start polling in a separate thread
poller_thread = threading.Thread(target=poll_file, args=('test_data.json', hash_table))
poller_thread.daemon = True
poller_thread.start()

# Simulate file updates
time.sleep(5)  # Let the poller run
with open('test_data.json', 'w') as f:
    json.dump({
        "driver_1": {
            "id": "driver_1",
            "name": "Jane Doe",
            "ride_history": ["ride_3"]
        }
    }, f)

time.sleep(5)  # Allow poller to reload the updated file
print(f"HashTable contents: {hash_table.table}")
from data_structures import HashTable, DoublyLinkedList
from save_load import save_data_to_file, load_data_from_file
from rating_system import RatingSystem
import uuid

class UserManagement:
    def __init__(self, islamabad_map):
        # Load users from file or initialize an empty HashTable
        self.users = load_data_from_file('users_data.json', HashTable) or HashTable()
        self.active_sessions = HashTable()  # Active sessions are temporary and not loaded
        self.islamabad_map = islamabad_map 

    def register_user(self, name, email, phone, password):
        user_id = str(uuid.uuid4())
        user_data = {
            'id': user_id,
            'name': name,
            'email': email,
            'phone': phone,
            'password': password,  # In real system, this should be hashed
            'ride_history': DoublyLinkedList(),
            'active_ride': None
        }

        if self.get_user_by_email(email):
            return False, "Email already registered"

        self.users.insert(user_id, user_data)

        # Save to file immediately
        save_data_to_file(self.users, 'users_data.json')
        return True, user_id

    def login_user(self, email, password):
        print("Debug: Users table contents:", self.users.table)  # Debug statement
        
        # Iterate through each bucket in the hash table
        for bucket in self.users.table:  
            print("Debug: Current bucket:", bucket)  # Debug statement
            
            if bucket:  # Check if the bucket is not empty
                for key, user_data in bucket:  # Iterate through key-value pairs
                    print("Debug: Checking user_data:", user_data)  # Debug statement
                    
                    # Validate user by email and password
                    if isinstance(user_data, dict) and user_data.get('email') == email and user_data.get('password') == password:
                        session_id = str(uuid.uuid4())  # Generate session ID
                        self.active_sessions.insert(session_id, user_data['id'])  # Map session ID to user ID
                        return True, session_id  # Successful login
            
        print("Active Sessions:", self.active_sessions.table)
        return False, "Invalid credentials"  # If no match is found


   
    '''def get_user_by_id(self, user_id):
        # Check if the provided user_id is a session ID
        original_user_id = self.active_sessions.get(user_id)
        if original_user_id:
            return self.users.get(original_user_id)
        return None  # Return None if neither session ID nor original user ID is found'''
    
    def get_user_by_id(self, user_id):
        """Get user by either their direct user ID or session ID."""
        print(f"Debug: Looking up user with ID: {user_id}")
        print(f"Debug: Current users in HashTable: {self.users.to_dict()}")
        
        # First try to get user directly from users table
        user = self.users.get(user_id)
        print(f"Debug: Direct user lookup result: {user}")
        
        if user:
            return user
            
        # If not found, check if it's a session ID
        original_user_id = self.active_sessions.get(user_id)
        print(f"Debug: Session lookup result: {original_user_id}")
        
        if original_user_id:
            return self.users.get(original_user_id)
            
        return None


    def get_user_by_email(self, email):
        for user_data in self.users.values():  # Use values() to get all user data
            if user_data['email'] == email:
                return user_data
        return None

    def update_user_profile(self, user_id, updates):
        user_data = self.users.get(user_id)
        if user_data:
            user_data.update(updates)
            self.users.insert(user_id, user_data)
            # Save updated data
            save_data_to_file(self.users, 'users_data.json')
            return True
        return False

    def provide_feedback(self, user_id):
        """Provide feedback for the user's most recent active ride."""
        # Load active rides from the JSON file
        active_rides = load_data_from_file('active_rides.json', HashTable) or HashTable()

        # Find the most recent active ride for the user
        recent_ride = None
        for ride in active_rides.values():  # Assuming active_rides is a HashTable
            if ride['user_id'] == user_id:
                recent_ride = ride  # Store the most recent ride found

        if not recent_ride:
            print("No active ride found for the user.")
            return

        # Retrieve the active ride data
        ride_id = recent_ride['id']  # Assuming ride data contains 'id'

        print("\n--- Post-Ride Feedback ---")
        try:
            rating = float(input("Rate the driver (1-5): "))  # Convert input to float
            feedback = input("Leave any additional feedback (optional): ")
            success, message = RatingSystem.post_ride_feedback(recent_ride['driver_id'], ride_id, rating, feedback)
            print(message)
        except ValueError:
            print("Invalid rating. Feedback skipped.")

    def visualize_last_active_ride_path(self, user_id):
        """Visualize the shortest path for the user's most recent active ride."""
        # Load active rides from the JSON file
        active_rides = load_data_from_file('active_rides.json', HashTable) or HashTable()

        # Find the most recent active ride for the user
        for ride in active_rides.values():  # Assuming active_rides is a HashTable
            if ride['user_id'] == user_id:
                pickup_location = ride['pickup_location']
                dropoff_location = ride['dropoff_location']

                # Visualize the ride path using the IslamabadMap instance
                try:
                    self.islamabad_map.visualize_ride_path(pickup_location, dropoff_location)
                except Exception as e:
                    print(f"Error visualizing ride path: {e}")
                return

        print("No active ride found for the user.")