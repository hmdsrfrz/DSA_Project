from data_structures import Graph
from save_load import save_data_to_file, load_data_from_file

# Dictionary of locations with their coordinates (x, y)
LOCATIONS = {
    # Sectors
    'F-6 Markaz': (0, 0),
    'F-7 Markaz': (2, 1),
    'G-9 Markaz': (-2, 3),
    'I-8 Markaz': (-4, 5),
    'E-11 Markaz': (-3, -2),
    'F-10 Markaz': (1, 3),
    'G-11 Markaz': (-1, 4),
    'F-17': (5, 7),
    'E-11': (-3, -3),
    'G-10': (0, 4),
    'D-12': (-5, -1),
    'F-11': (2, 4),
    'G-6': (-1, 1),

    # Universities
    'IIUI': (-6, 6),
    'Air University': (3, 5),
    'FAST University': (1, 2),
    'COMSATS': (4, 3),
    'NUST': (-2, 6),

    # Landmarks
    'Faisal Mosque': (0, 5),
    'Shakarparian': (3, -1),
    'Pakistan Monument': (2, -2),
    'Daman-e-Koh': (1, 6),
    'Centaurus Mall': (2, 0),
    'Serena Hotel': (1, 1)
}

# Dictionary of direct distances between connected locations
DISTANCES = {
    # Major connections between sectors
    ('F-6 Markaz', 'F-7 Markaz'): 3,
    ('F-7 Markaz', 'F-10 Markaz'): 4,
    ('F-10 Markaz', 'F-11'): 2,
    ('G-9 Markaz', 'G-10'): 2,
    ('G-10', 'G-11 Markaz'): 3,
    ('E-11 Markaz', 'E-11'): 1,
    ('I-8 Markaz', 'G-9 Markaz'): 5,

    # Connections to universities
    ('F-7 Markaz', 'FAST University'): 3,
    ('G-11 Markaz', 'NUST'): 4,
    ('F-10 Markaz', 'Air University'): 4,
    ('G-9 Markaz', 'COMSATS'): 6,
    ('E-11', 'IIUI'): 8,

    # Connections to landmarks
    ('F-7 Markaz', 'Centaurus Mall'): 2,
    ('F-6 Markaz', 'Serena Hotel'): 2,
    ('G-10', 'Faisal Mosque'): 3,
    ('F-11', 'Daman-e-Koh'): 4,
    ('F-7 Markaz', 'Pakistan Monument'): 4,
    ('F-6 Markaz', 'Shakarparian'): 5,

    # Additional strategic connections
    ('G-6', 'F-6 Markaz'): 2,
    ('G-6', 'G-9 Markaz'): 4,
    ('F-10 Markaz', 'G-10'): 2,
    ('F-11', 'E-11'): 5,
    ('D-12', 'E-11'): 3,
    ('F-17', 'Air University'): 4
}

class IslamabadMap:
    def __init__(self, file_path='map_data.json'):
        self.file_path = file_path
        self.graph = load_data_from_file(self.file_path, Graph) or self._initialize_map()
        self.locations = LOCATIONS  # Dictionary of locations and their coordinates
        self.distances = DISTANCES  # Dictionary of distances between locations

    def _initialize_map(self):
        graph = Graph()
        for location in LOCATIONS:
            graph.add_node(location)
        for (start, end), distance in DISTANCES.items():
            graph.add_edge(start, end, distance)
        save_data_to_file(self.file_path, graph)
        return graph

    def get_location_coordinates(self, location):
        """Get the coordinates of a specific location."""
        return LOCATIONS.get(location)

    def get_direct_distance(self, start, end):
        """Get the direct distance between two locations if they're directly connected."""
        return DISTANCES.get((start, end)) or DISTANCES.get((end, start))

    def get_shortest_path_distance(self, start, end):
        if start not in self.graph.nodes or end not in self.graph.nodes:
            return None
        distances, _ = self.graph.dijkstra(start)
        return distances.get(end, float('inf'))

    def get_nearby_locations(self, location, max_distance):
        """Get all locations within a specified distance of a given location."""
        if location not in LOCATIONS:
            return []
        distances = self.graph.dijkstra(location)
        return [loc for loc, dist in distances.items() if 0 < dist <= max_distance]

    def get_all_locations(self):
        """Return a list of all locations in the map."""
        return list(LOCATIONS.keys())

    def get_location_type(self, location):
        """Return the type of location (Sector, University, or Landmark)."""
        if location not in LOCATIONS:
            return None
        if 'University' in location or 'NUST' in location or 'IIUI' in location or 'COMSATS' in location:
            return 'University'
        if any(sector in location for sector in ['F-', 'G-', 'I-', 'E-', 'D-']):
            return 'Sector'
        return 'Landmark'

# Helper functions for the map
def is_valid_location(location):
    """Check if a location exists in the map."""
    return location in LOCATIONS

def get_distance_matrix():
    """Generate a complete distance matrix between all locations."""
    map_instance = IslamabadMap()
    locations = list(LOCATIONS.keys())
    matrix = {}

    for start in locations:
        matrix[start] = {}
        distances, _ = map_instance.graph.dijkstra(start)
        for end in locations:
            matrix[start][end] = distances.get(end, float('inf'))

    return matrix
import networkx as nx
import matplotlib.pyplot as plt

def visualize_map(location_service):
    """
    Visualizes the map using the graph data from the location service.
    """
    G = nx.Graph()

    # Retrieve locations and distances from the map data
    locations = location_service.map_data.get_all_locations()
    distances = location_service.map_data.get_distances()

    # Add nodes
    for location in locations:
        G.add_node(location)

    # Add edges with weights
    for (start, end), distance in distances.items():
        G.add_edge(start, end, weight=distance)

    # Visualization
    pos = nx.spring_layout(G)
    plt.figure(figsize=(10, 8))
    plt.gca().set_facecolor('black')

    nx.draw(
        G, pos,
        with_labels=True,
        node_color='lightgrey',
        edge_color='red',
        font_color='white',
        node_size=2000,
        font_size=10
    )

    labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_color='white')

    plt.title("Islamabad Ride-Hailing Map", color='white', fontsize=14)
    plt.show()

def visualize_ride_path(location_service, start, end):
    """
    Visualizes the shortest ride path between two locations.
    """
    distance, path = location_service.get_shortest_path(start, end)
    if path:
        G = nx.Graph()

        # Retrieve locations and distances from the map data
        locations = location_service.map_data.get_all_locations()
        distances = location_service.map_data.get_distances()

        # Add nodes
        for location in locations:
            G.add_node(location)

        # Add edges with weights
        for (start_node, end_node), distance in distances.items():
            G.add_edge(start_node, end_node, weight=distance)

        pos = nx.spring_layout(G)
        nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=2000, font_size=10)

        # Highlight the path edges
        path_edges = [(path[i], path[i + 1]) for i in range(len(path) - 1)]
        nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='red', width=2)

        labels = nx.get_edge_attributes(G, 'weight')
        nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

        plt.title(f"Ride Path from {start} to {end} (Distance: {distance})")
        plt.show()
    else:
        print("No path found between the selected locations.")
from data_structures import Graph
from map_data import IslamabadMap
from save_load import save_data_to_file, load_data_from_file

class LocationService:
    def __init__(self, map_data: IslamabadMap, file_path='location_service.json'):
        self.map_data = map_data  # Store map_data as an instance variable
        self.file_path = file_path
        self.graph = load_data_from_file(self.file_path, Graph)
        if not self.graph:
            self.graph = Graph()
            self._initialize_map()
            save_data_to_file(self.graph, self.file_path)

    def _initialize_map(self):
        """
        Initializes the graph with locations and distances from the IslamabadMap instance.
        """
        # Add all locations as nodes
        locations = self.map_data.get_all_locations()
        for location in locations:
            self.graph.add_node(location)

        # Add all distances as edges
        for (start, end), distance in self.map_data.DISTANCES.items():
            self.graph.add_edge(start, end, distance)
            # Add reverse direction since roads are typically bidirectional
            self.graph.add_edge(end, start, distance)

    def get_shortest_path(self, start, end):
        """Get the shortest path and its distance between two locations."""
        if not self.is_valid_location(start) or not self.is_valid_location(end):
            return None, "Invalid locations provided."
        
        try:
            distances, previous_nodes = self.graph.dijkstra_with_path(start)
            if distances[end] == float('inf'):
                return None, "No path exists between the specified locations."
            
            # Reconstruct path
            path = []
            current = end
            while current:
                path.insert(0, current)
                current = previous_nodes.get(current)
                
            return path, distances[end]
        except Exception as e:
            return None, f"Error calculating path: {str(e)}"

    def get_nearby_locations(self, location, max_distance):
        """Gets all locations within a specified distance from the given location."""
        if not self.is_valid_location(location):
            return []
        
        try:
            distances, _ = self.graph.dijkstra(location)
            return [loc for loc, dist in distances.items() if 0 < dist <= max_distance]
        except Exception:
            return []

    def get_distance_between(self, start, end):
        """Returns the shortest path distance between two locations."""
        if not self.is_valid_location(start) or not self.is_valid_location(end):
            return None
            
        try:
            distances, _ = self.graph.dijkstra(start)
            distance = distances.get(end)
            return None if distance == float('inf') else distance
        except Exception:
            return None

    def is_valid_location(self, location):
        """Checks if a location exists in the map."""
        return location in self.graph.nodes

    def save(self):
        """Save the current state of the graph."""
        save_data_to_file(self.graph, self.file_path)
import threading
import time
import os
import networkx as nx
import matplotlib.pyplot as plt
import sys

sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from user_management import UserManagement
from driver_management import DriverManagement
from ride_request import RideRequest
from location_service import LocationService
from emergency_handler import EmergencyHandler
from social_rideshare import SocialRideshare
from pricing import Pricing
from ride_history import RideHistory
from map_data import IslamabadMap, is_valid_location, LOCATIONS
from data_structures import Graph, HashTable
from map_visualization import visualize_map, visualize_ride_path
from friend_management import FriendManagement


class Dashboards:
    def __init__(self, user_mgmt, driver_mgmt, ride_request, location_service, pricing, ride_history, emergency_handler, friend_mgmt):
        self.user_mgmt = user_mgmt
        self.driver_mgmt = driver_mgmt
        self.ride_request = ride_request
        self.location_service = location_service
        self.pricing = pricing
        self.ride_history = ride_history
        self.emergency_handler = emergency_handler
        self.friend_mgmt = friend_mgmt

    def run_user_login(self):
        print("\n--- User Login ---")
        email = input("Enter email: ")
        password = input("Enter password: ")

        success, result = self.user_mgmt.login_user(email, password)
        if success:
            session_id = result
            print("Login successful!")
            print("Session ID after login:", session_id)
            self.user_dashboard(session_id)  # Pass session_id to access the dashboard
        else:
            print(result)  # Print error message from login failure

    def run_user_signup(self):
        print("\n--- User Signup ---")
        name = input("Enter your name: ")
        email = input("Enter email: ")
        phone = input("Enter phone number: ")
        password = input("Enter password: ")

        success, result = self.user_mgmt.register_user(name, email, phone, password)
        if success:
            self.user_mgmt.users.save_to_file('users_data.json')
            print(f"Signup successful! Your user ID is {result}")
            self.run_user_login()  # After successful signup, redirect to login
        else:
            print(result)  # Print error message from signup failure

    def user_dashboard(self, user_id):
        '''user_id = self.user_mgmt.get_user_by_session(user_id)
        if not user_id:
                print("Error: User ID not found for session.")
                return'''
        
        print("User ID in Dashboard:", user_id)
        while True:
            updates = self.ride_request.get_user_updates(user_id)
            if updates:
                if updates['type'] == 'ride_accepted':
                    print(f"\nRide accepted by driver {updates['driver']['name']}!")
                    print(f"Driver phone: {updates['driver']['phone']}")
                    print(f"Vehicle type: {updates['driver']['vehicle_type']}")

            print("\n--- User Dashboard ---")
            print("1. Request Ride")
            print("2. View Ride History")
            print("3. Select Location")
            print("4. Book Emergency Ride")
            print("5. View Friends")
            print("6. Add Friend")
            print("7. View Friend Requests")
            print("8. Visualize Map")
            print("9. Logout")
            print("10. See available drivers")

            choice = input("Enter your choice: ")

            if choice == '1':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                try:
                    # Prompt the user to select pickup and destination locations
                    pickup_index = int(input("Enter the number for your pickup location: "))
                    destination_index = int(input("Enter the number for your destination: "))

                    # Validate user input
                    if pickup_index < 1 or pickup_index > len(all_locations) or destination_index < 1 or destination_index > len(all_locations):
                        print("Invalid selection. Please choose valid location numbers.")
                        continue  # Continue to the next iteration of the loop

                    pickup = all_locations[pickup_index - 1]
                    destination = all_locations[destination_index - 1]

                    # Ensure pickup and destination are not the same
                    if pickup == destination:
                        print("Pickup and destination locations cannot be the same. Please try again.")
                        continue  # Continue to the next iteration of the loop

                    # Validate the locations and proceed with the ride request
                    if is_valid_location(pickup) and is_valid_location(destination):
                        success, ride_id = self.ride_request.request_ride(user_id, pickup, destination)
                        if success:
                            print("Ride requested successfully. Ride ID:", ride_id)
                            visualize_ride_path(islamabad_map, pickup, destination)
                        else:
                            print("Failed to request ride.")
                    else:
                        print("Invalid locations. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter numbers corresponding to the locations.")

            elif choice == '2':
                history = self.ride_history.get_ride_history()
                print("--- Ride History ---")
                for ride in history:
                    print(ride)
            elif choice == '3':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                location = input("Select your current location: ")

                # Validate the location using IslamabadMap
                if is_valid_location(location):
                    self.user_mgmt.update_user_profile(user_id, {'location': location})
                    print("Location updated.")
                else:
                    print("Invalid location. Please select a valid location from the available options.")

            elif choice == '4':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                try:
                    # Prompt the user to select pickup and destination locations
                    pickup_index = int(input("Enter the number for your pickup location: "))
                    destination_index = int(input("Enter the number for your emergency destination: "))

                    # Validate user input
                    if pickup_index < 1 or pickup_index > len(all_locations) or destination_index < 1 or destination_index > len(all_locations):
                        print("Invalid selection. Please choose valid location numbers.")
                        continue  # Continue to the next iteration of the loop

                    pickup = all_locations[pickup_index - 1]
                    destination = all_locations[destination_index - 1]

                    # Ensure pickup and destination are not the same
                    if pickup == destination:
                        print("Pickup and destination locations cannot be the same. Please try again.")
                        continue  # Continue to the next iteration of the loop

                    # Validate the locations and proceed with the emergency request
                    if is_valid_location(pickup) and is_valid_location(destination):
                        success, ride_id = self.emergency_handler.add_emergency_request(user_id, pickup, destination)
                        if success:
                            print("Emergency ride booked successfully. Ride ID:", ride_id)
                            visualize_ride_path(islamabad_map, pickup, destination)
                        else:
                            print("Failed to book emergency ride.")
                    else:
                        print("Invalid locations. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter numbers corresponding to the locations.")

            elif choice == '5':
                friends = self.friend_mgmt.get_friends_list(user_id)
                print("\n--- Your Friends ---")
                for idx, (friend_id, friend_data) in enumerate(friends, 1):
                    print(f"{idx}. {friend_data['name']} ({friend_data['email']})")

            elif choice == '6':
                users = self.friend_mgmt.display_all_users()
                if users:
                    choice = input("\nEnter the number of the user to add: ")
                    try:
                        idx = int(choice)
                        success, message = self.friend_mgmt.send_friend_request(user_id, idx, users)
                        print(message)
                    except ValueError:
                        print("Invalid input")

            elif choice == '7':
                pending_requests = self.friend_mgmt.get_pending_requests(user_id)
                if not pending_requests:
                    print("No pending friend requests")
                else:
                    print("\n--- Pending Friend Requests ---")
                    for idx, (from_id, from_user) in enumerate(pending_requests, 1):
                        print(f"{idx}. {from_user['name']} ({from_user['email']})")
                    choice = input("\nEnter request number to accept (or 0 to skip): ")
                    try:
                        idx = int(choice)
                        if idx > 0:
                            success, message = self.friend_mgmt.accept_friend_request(
                                user_id, idx, pending_requests)
                            print(message)
                    except ValueError:
                        print("Invalid input")
            elif choice == '8':
                visualize_map(self.location_service)
            elif choice == '10':
                 self.see_available_drivers()
            elif choice == '9':
                print("Logging out...")
                break
            else:
                print("Invalid choice. Please try again.")

    def see_available_drivers(self):
        print("\n--- Available Drivers ---")
        available_drivers = self.driver_mgmt.get_available_drivers()
        if not available_drivers:
            print("No drivers are currently available.")
            return

        for idx, driver in enumerate(available_drivers, 1):
            print(f"\nDriver {idx}:")
            print(f"Name: {driver['name']}")
            print(f"Vehicle Type: {driver['vehicle_type']}")
            print(f"Current Location: {driver.get('current_location', 'Unknown')}")
            print(f"Availability: {driver.get('availability', 'Not Set')}")


    def run_driver_login(self):
        print("\n--- Driver Login ---")
        email = input("Enter email: ")
        password = input("Enter password: ")

        success, result = self.driver_mgmt.login_driver(email, password)
        if success:
            driver_id = result
            print("Login successful!")
            self.driver_dashboard(driver_id)  # Pass driver_id to access the dashboard
        else:
            print(result)  # Print error message from login failure

    def run_driver_signup(self):
        print("\n--- Driver Signup ---")
        name = input("Enter your name: ")
        email = input("Enter email: ")
        phone = input("Enter phone number: ")
        password = input("Enter password: ")
        vehicle_type = input("Enter vehicle type: ")
        license_number = input("Enter license number: ")

        success, result = self.driver_mgmt.register_driver(name, email, phone, password, vehicle_type, license_number)
        if success:
            self.driver_mgmt.drivers.save_to_file('drivers_data.json')
            print(f"Signup successful! Your driver ID is {result}")
            self.run_driver_login()  # After successful signup, redirect to login
        else:
            print(result)  # Print error message from signup failure

    

    def driver_dashboard(self, driver_id):
        while True:
            print("\n--- Driver Dashboard ---")
            print("1. Toggle Availability")
            print("2. View Ride History")
            print("3. Update Location")
            print("4. View Available Requests")
            print("5. Complete Ride")
            print("6. Visualize Map")
            print("7. Logout")
            print("8. See available drivers")

            choice = input("Enter your choice: ")

            if choice == '1':
                status = input("Enter 'on' to be available or 'off' to go offline: ").lower()
                available = status == 'on'
                self.driver_mgmt.set_driver_availability(driver_id, available)
                print("Availability updated.")
            elif choice == '2':
                history = self.ride_history.get_ride_history()
                print("--- Ride History ---")
                for ride in history:
                    print(ride)
            elif choice == '3':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                try:
                    # Prompt the driver to select their current location
                    location_index = int(input("Enter the number for your current location: "))

                    # Validate user input
                    if location_index < 1 or location_index > len(all_locations):
                        print("Invalid selection. Please choose a valid location number.")
                        continue  # Continue to the next iteration of the loop

                    location = all_locations[location_index - 1]

                    # Validate the location and update the driver's location
                    if is_valid_location(location):
                        self.driver_mgmt.update_driver_location(driver_id, location)
                        print("Location updated.")
                    else:
                        print("Invalid location. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter a number corresponding to the locations.")

            elif choice == '4':
                # Ensure driver location is updated
                driver = self.driver_mgmt.get_driver_by_id(driver_id)
                if not driver['current_location']:
                    print("Please update your location first.")
                    continue

                # Call the view_ride_requests function to display and handle requests
                DriverManagement.view_ride_requests(driver_id)

            elif choice == '5':
                driver = self.driver_mgmt.get_driver_by_id(driver_id)
                if not driver['active_ride']:
                    print("You don't have any active rides.")
                    continue

                ride_id = driver['active_ride']
                success, message = self.ride_request.complete_ride(ride_id)
                print(message)

            elif choice == '6':
                visualize_map(self.location_service)

            elif choice == '7':
                print("Logging out...")

            elif choice == '8':
                 self.see_available_drivers()
                 break

            else:
                print("Invalid choice. Please try again.")#data_structures.py
import json
from save_load import save_data_to_file, load_data_from_file

class MinHeap:
    def __init__(self):
        self.heap = []

    def push(self, item):
        self.heap.append(item)
        self._heapify_up(len(self.heap) - 1)

    def pop(self):
        if len(self.heap) == 0:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()
        root = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)
        return root

    def _heapify_up(self, index):
        parent = (index - 1) // 2
        if index > 0 and self.heap[index] < self.heap[parent]:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            self._heapify_up(parent)

    def _heapify_down(self, index):
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        if left < len(self.heap) and self.heap[left] < self.heap[smallest]:
            smallest = left
        if right < len(self.heap) and self.heap[right] < self.heap[smallest]:
            smallest = right
        if smallest != index:
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
            self._heapify_down(smallest)

    def peek(self):
        if self.heap:
            return self.heap[0]
        return None
    def is_empty(self):
        return len(self.heap) == 0

    def size(self):
        return len(self.heap)



class Graph:
    def __init__(self):
        self.nodes = {}

    def add_node(self, location):
        if location not in self.nodes:
            self.nodes[location] = {}

    def add_edge(self, start, end, distance):
        if start in self.nodes and end in self.nodes:
            self.nodes[start][end] = distance
            self.nodes[end][start] = distance  # Since it's an undirected graph

    def get_neighbors(self, node):
        return self.nodes.get(node, {})

    def dijkstra(self, start):
        """
        Implementation of Dijkstra's shortest path algorithm using MinHeap.
        
        Args:
            start: Starting node
            
        Returns:
            Dictionary of shortest distances to all nodes from start node
            Dictionary of previous nodes in the shortest path
        """
        # Initialize distances with infinity for all nodes except start
        distances = {node: float('infinity') for node in self.nodes}
        distances[start] = 0
        
        # Dictionary to store the previous node in shortest path
        previous = {node: None for node in self.nodes}
        
        # Create min heap for storing vertices to visit
        pq = MinHeap()
        pq.push((0, start))  # (distance, node)
        
        # Set to keep track of visited nodes
        visited = set()
        
        while not pq.is_empty():
            # Get the node with minimum distance
            current_distance, current_node = pq.pop()
            
            # If we've already processed this node, skip it
            if current_node in visited:
                continue
                
            # Mark node as visited
            visited.add(current_node)
            
            # If current distance is greater than known distance, skip
            if current_distance > distances[current_node]:
                continue
            
            # Check all neighbors of current node
            for neighbor, weight in self.nodes[current_node].items():
                # Skip if neighbor is already visited
                if neighbor in visited:
                    continue
                    
                # Calculate tentative distance to neighbor
                distance = current_distance + weight
                
                # If we found a shorter path, update it
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_node
                    pq.push((distance, neighbor))
        
        return distances, previous

    def get_shortest_path(self, start, end):
        """
        Gets the shortest path between start and end nodes.
        
        Args:
            start: Starting node
            end: Ending node
            
        Returns:
            tuple: (path_distance, path_nodes)
            where path_distance is the total distance
            and path_nodes is a list of nodes in the path
        """
        # Get shortest distances and previous nodes
        distances, previous = self.dijkstra(start)
        
        if distances[end] == float('infinity'):
            return None, None  # No path exists
            
        # Reconstruct the path
        path = []
        current = end
        
        while current is not None:
            path.append(current)
            current = previous[current]
            
        # Reverse path to get it from start to end
        path.reverse()
        
        return distances[end], path
    

    def get_shortest_path_distance(self, start, end):
        if start not in self.nodes or end not in self.nodes:
            return None
        distances, _ = self.dijkstra(start)
        return distances.get(end, float('inf'))



    def get_all_paths(self, start):
        """
        Gets all shortest paths from start node to all other nodes.
        
        Args:
            start: Starting node
            
        Returns:
            Dictionary with end nodes as keys and (distance, path) tuples as values
        """
        distances, previous = self.dijkstra(start)
        paths = {}
        
        for end in self.nodes:
            if end == start:
                paths[end] = (0, [start])
                continue
                
            if distances[end] == float('infinity'):
                paths[end] = (None, None)
                continue
                
            # Reconstruct path
            path = []
            current = end
            while current is not None:
                path.append(current)
                current = previous[current]
            path.reverse()
            
            paths[end] = (distances[end], path)
            
        return paths
    
    def to_dict(self):
        """
        Converts the Graph into a dictionary for serialization.
        """
        return {"nodes": self.nodes}

    @classmethod
    def from_dict(cls, data):
        """
        Reconstructs a Graph from a dictionary.
        """
        new_graph = cls()
        new_graph.nodes = data.get("nodes", {})
        return new_graph

class DoublyLinkedList:
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None
            self.prev = None

    def __init__(self):
        self.head = None
        self.tail = None

    def to_list(self):
        """Convert the linked list into a list."""
        result = []
        current = self.head
        while current:
            result.append(current.data)  # Assuming each node has a 'data' attribute
            current = current.next
        return result

    @classmethod
    def from_list(cls, data_list):
        """Reconstruct the linked list from a list."""
        new_list = cls()
        for item in data_list:
            new_list.append(item)  # Assuming an `append` method exists
        return new_list

    def append(self, data):
        new_node = self.Node(data)
        if not self.head:
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def traverse_forward(self):
        current = self.head
        while current:
            print(current.data)
            current = current.next

    def traverse_backward(self):
        current = self.tail
        while current:
            print(current.data)
            current = current.prev

    def to_list(self):
        """
        Converts the DoublyLinkedList into a standard Python list.
        """
        result = []
        current = self.head
        while current:
            result.append(current.data)  # Assuming each node has a 'data' attribute
            current = current.next
        return result

    @classmethod
    def from_list(cls, data_list):
        """
        Creates a DoublyLinkedList from a standard Python list.
        """
        new_list = cls()
        for item in data_list:
            new_list.append(item)  # Assuming an `append` method exists
        return new_list
    
    def delete(self, data):
        current = self.head
        while current:
            if current.data == data:
                if current.prev:
                    current.prev.next = current.next
                if current.next:
                    current.next.prev = current.prev
                if current == self.head:
                    self.head = current.next
                if current == self.tail:
                    self.tail = current.prev
                return
            current = current.next

class HashTable:
    def __init__(self, size=10):  # Initialize with a default size
        self.table = {}  # Use a dictionary to store key-value pairs

    def hash_function(self, key):
        # Simple hash function (you can implement more sophisticated ones)
        hash_value = hash(key) % len(self.table) if self.table else 0
        return hash_value
    
    def save_to_file(self, filename):
        save_data_to_file(self.to_dict(), filename)

    def load_from_file(self, filename):
        loaded_data = load_data_from_file(filename, dict)
        if loaded_data:
            self.table = loaded_data

    def to_dict(self):
        """
        Converts the HashTable into a standard Python dictionary.
        Handles special serialization for nested DoublyLinkedList objects.
        """
        result = {}
        for bucket in self.table.values():
            if bucket:
                for key, value in bucket:
                    # Convert DoublyLinkedList to list if present
                    if isinstance(value, dict) and 'ride_history' in value:
                        value = value.copy()  # Avoid modifying the original value
                        value['ride_history'] = value['ride_history'].to_list()
                    result[key] = value
        return result

    @classmethod
    def from_dict(cls, data_dict):
        """
        Creates a HashTable from a standard Python dictionary.
        Handles special deserialization for nested DoublyLinkedList objects.
        """
        new_table = cls()
        for key, value in data_dict.items():
            # Deserialize DoublyLinkedList if present
            if isinstance(value, dict) and 'ride_history' in value:
                value = value.copy()
                value['ride_history'] = DoublyLinkedList.from_list(value['ride_history'])
            new_table.insert(key, value)
        return new_table

    def insert(self, key, value):
        index = self.hash_function(key)
        if index not in self.table:
            self.table[index] = []
        self.table[index].append((key, value))  # Handle collisions by storing in list

    def get(self, key):
        index = self.hash_function(key)
        if index in self.table:
            for k, v in self.table[index]:
                if k == key:
                    return v
        return None

    def delete(self, key):
        index = self.hash_function(key)
        if index in self.table:
            for i, (k, v) in enumerate(self.table[index]):
                if k == key:
                    del self.table[index][i]
                    break

    def values(self):
        # Flatten the table and return all values
        return [value for bucket in self.table.values() for key, value in bucket]

    def items(self):
        # Flatten the table and return all key-value pairs
        return [(key, value) for bucket in self.table.values() for key, value in bucket]

class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, item):
        self.queue.append(item)

    def dequeue(self):
        if self.queue:
            return self.queue.pop(0)
        return None

    def is_empty(self):
        return len(self.queue) == 0

    def peek(self):
        if self.queue:
            return self.queue[0]
        return None
    
    def to_dict(self):
        """
        Converts the Queue into a dictionary for serialization.
        """
        return {"queue": self.queue}

    @classmethod
    def from_dict(cls, data):
        """
        Reconstructs a Queue from a dictionary.
        """
        new_queue = cls()
        new_queue.queue = data.get("queue", [])
        return new_queue

class PriorityQueue(MinHeap):
    def __init__(self):
        super().__init__()

    def push(self, priority, item):
        super().push((priority, item))

    def pop(self):
        return super().pop()[1] if self.heap else None

    def peek(self):
        return self.heap[0][1] if self.heap else None

    def to_dict(self):
        """
        Converts the PriorityQueue into a dictionary for serialization.
        """
        return {"heap": self.heap}

    @classmethod
    def from_dict(cls, data):
        """
        Reconstructs a PriorityQueue from a dictionary.
        """
        new_pq = cls()
        new_pq.heap = data.get("heap", [])
        return new_pq

class AVLTree:
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.value = value
            self.height = 1
            self.left = None
            self.right = None

    def __init__(self):
        self.root = None

    # Implement AVL Tree methods (insert, delete, rotate, balance) as needed

# Additional data structures can be added here if necessary for the project requirements.
#main.py
import threading
import networkx as nx
import matplotlib.pyplot as plt
from user_management import UserManagement
from driver_management import DriverManagement
from friend_management import FriendManagement
from ride_request import RideRequest
from location_service import LocationService
from emergency_handler import EmergencyHandler
from social_rideshare import SocialRideshare
from pricing import Pricing
from ride_history import RideHistory
from map_data import IslamabadMap
from data_structures import Graph
from data_structures import HashTable
from polling import poll_file, reload_drivers, reload_users

from dashboards import Dashboards
from map_visualization import visualize_map, visualize_ride_path


def initialize_system():
    """Initialize all system components in the correct order"""
    # Initialize base services first
    map_data = IslamabadMap()
    location_service = LocationService(map_data)
    pricing = Pricing()
    
    # Initialize management systems
    user_mgmt = UserManagement()
    driver_mgmt = DriverManagement()
    friend_mgmt = FriendManagement(user_mgmt)
    ride_history = RideHistory()
    
    # Initialize ride request system with all required dependencies
    ride_request = RideRequest(
        user_management=user_mgmt,
        driver_management=driver_mgmt,
        location_service=location_service,
        pricing=pricing
    )
    
    # Initialize additional services that depend on core components
    emergency_handler = EmergencyHandler(ride_request, location_service, driver_mgmt)
    social_rideshare = SocialRideshare()
    
    # Initialize dashboard last as it depends on all other components
    dashboards = Dashboards(user_mgmt, driver_mgmt, ride_request, location_service, pricing, ride_history, emergency_handler, friend_mgmt)
    
    return {
        'user_mgmt': user_mgmt,
        'driver_mgmt': driver_mgmt,
        'location_service': location_service,
        'pricing': pricing,
        'ride_request': ride_request,
        'emergency_handler': emergency_handler,
        'social_rideshare': social_rideshare,
        'dashboards': dashboards,
        'ride_history': ride_history
    }

def main():

    # Initialize the system
    system = initialize_system()
    Dashboards = system['dashboards']

    # Start polling threads for user and driver data
    user_poll_thread = threading.Thread(target=poll_file, args=('users_data.json', reload_users), daemon=True)
    driver_poll_thread = threading.Thread(target=poll_file, args=('drivers_data.json', reload_drivers), daemon=True)
    user_poll_thread.start()
    driver_poll_thread.start()

    while True:
        try:
            print("\n--- Main Menu ---")
            print("1. User Login")
            print("2. Driver Login")
            print("3. User Signup")
            print("4. Driver Signup")
            print("5. Exit")
            
            choice = input("Enter your choice: ")
            
            if choice == '1':
                Dashboards.run_user_login()
            elif choice == '2':
                Dashboards.run_driver_login()
            elif choice == '3':
                Dashboards.run_user_signup()
            elif choice == '4':
                Dashboards.run_driver_signup()
            elif choice == '5':
                print("Exiting...")
                break
            else:
                print("Invalid choice. Please try again.")
        except KeyboardInterrupt:
            print("\nProgram interrupted. Exiting gracefully.")
            break

if __name__ == "__main__":
    main()
