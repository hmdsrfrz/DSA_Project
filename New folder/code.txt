DataStructures.py

import json
class MinHeap:
    def __init__(self):
        self.heap = []

    def push(self, item):
        self.heap.append(item)
        self._heapify_up(len(self.heap) - 1)

    def pop(self):
        if len(self.heap) == 0:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()
        root = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)
        return root

    def _heapify_up(self, index):
        parent = (index - 1) // 2
        if index > 0 and self.heap[index] < self.heap[parent]:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            self._heapify_up(parent)

    def _heapify_down(self, index):
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        if left < len(self.heap) and self.heap[left] < self.heap[smallest]:
            smallest = left
        if right < len(self.heap) and self.heap[right] < self.heap[smallest]:
            smallest = right
        if smallest != index:
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
            self._heapify_down(smallest)

    def peek(self):
        if self.heap:
            return self.heap[0]
        return None
    def is_empty(self):
        return len(self.heap) == 0

    def size(self):
        return len(self.heap)



class Graph:
    def __init__(self):
        self.nodes = {}

    def add_node(self, location):
        if location not in self.nodes:
            self.nodes[location] = {}

    def add_edge(self, start, end, distance):
        if start in self.nodes and end in self.nodes:
            self.nodes[start][end] = distance
            self.nodes[end][start] = distance  # Since it's an undirected graph

    def get_neighbors(self, node):
        return self.nodes.get(node, {})

    def dijkstra(self, start):
        """
        Implementation of Dijkstra's shortest path algorithm using MinHeap.
        
        Args:
            start: Starting node
            
        Returns:
            Dictionary of shortest distances to all nodes from start node
            Dictionary of previous nodes in the shortest path
        """
        # Initialize distances with infinity for all nodes except start
        distances = {node: float('infinity') for node in self.nodes}
        distances[start] = 0
        
        # Dictionary to store the previous node in shortest path
        previous = {node: None for node in self.nodes}
        
        # Create min heap for storing vertices to visit
        pq = MinHeap()
        pq.push((0, start))  # (distance, node)
        
        # Set to keep track of visited nodes
        visited = set()
        
        while not pq.is_empty():
            # Get the node with minimum distance
            current_distance, current_node = pq.pop()
            
            # If we've already processed this node, skip it
            if current_node in visited:
                continue
                
            # Mark node as visited
            visited.add(current_node)
            
            # If current distance is greater than known distance, skip
            if current_distance > distances[current_node]:
                continue
            
            # Check all neighbors of current node
            for neighbor, weight in self.nodes[current_node].items():
                # Skip if neighbor is already visited
                if neighbor in visited:
                    continue
                    
                # Calculate tentative distance to neighbor
                distance = current_distance + weight
                
                # If we found a shorter path, update it
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_node
                    pq.push((distance, neighbor))
        
        return distances, previous

    def get_shortest_path(self, start, end):
        """
        Gets the shortest path between start and end nodes.
        
        Args:
            start: Starting node
            end: Ending node
            
        Returns:
            tuple: (path_distance, path_nodes)
            where path_distance is the total distance
            and path_nodes is a list of nodes in the path
        """
        # Get shortest distances and previous nodes
        distances, previous = self.dijkstra(start)
        
        if distances[end] == float('infinity'):
            return None, None  # No path exists
            
        # Reconstruct the path
        path = []
        current = end
        
        while current is not None:
            path.append(current)
            current = previous[current]
            
        # Reverse path to get it from start to end
        path.reverse()
        
        return distances[end], path

    def get_all_paths(self, start):
        """
        Gets all shortest paths from start node to all other nodes.
        
        Args:
            start: Starting node
            
        Returns:
            Dictionary with end nodes as keys and (distance, path) tuples as values
        """
        distances, previous = self.dijkstra(start)
        paths = {}
        
        for end in self.nodes:
            if end == start:
                paths[end] = (0, [start])
                continue
                
            if distances[end] == float('infinity'):
                paths[end] = (None, None)
                continue
                
            # Reconstruct path
            path = []
            current = end
            while current is not None:
                path.append(current)
                current = previous[current]
            path.reverse()
            
            paths[end] = (distances[end], path)
            
        return paths

class DoublyLinkedList:
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None
            self.prev = None

    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, data):
        new_node = self.Node(data)
        if not self.head:
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def traverse_forward(self):
        current = self.head
        while current:
            print(current.data)
            current = current.next

    def traverse_backward(self):
        current = self.tail
        while current:
            print(current.data)
            current = current.prev

    def delete(self, data):
        current = self.head
        while current:
            if current.data == data:
                if current.prev:
                    current.prev.next = current.next
                if current.next:
                    current.next.prev = current.prev
                if current == self.head:
                    self.head = current.next
                if current == self.tail:
                    self.tail = current.prev
                return
            current = current.next

class HashTable:
    def __init__(self, size=10):  # Initialize with a default size
        self.table = {}  # Use a dictionary to store key-value pairs

    def hash_function(self, key):
        # Simple hash function (you can implement more sophisticated ones)
        hash_value = hash(key) % len(self.table) if self.table else 0
        return hash_value

    def save_to_file(self, filename):
        # Convert hash table to a dictionary and save it as JSON
        table_data = {}
        for bucket in self.table:
            if bucket:
                for key, value in bucket:
                    table_data[key] = value
        with open(filename, 'w') as f:
            json.dump(table_data, f)

    def load_from_file(self, filename):
        try:
            with open(filename, 'r') as f:
                table_data = json.load(f)
                # Reinsert data into hash table
                for key, value in table_data.items():
                    self.insert(key, value)
        except FileNotFoundError:
            print("No saved data found. Starting with an empty table.")

    def insert(self, key, value):
        index = self.hash_function(key)
        if index not in self.table:
            self.table[index] = []
        self.table[index].append((key, value))  # Handle collisions by storing in list

    def get(self, key):
        index = self.hash_function(key)
        if index in self.table:
            for k, v in self.table[index]:
                if k == key:
                    return v
        return None

    def delete(self, key):
        index = self.hash_function(key)
        if index in self.table:
            for i, (k, v) in enumerate(self.table[index]):
                if k == key:
                    del self.table[index][i]
                    break

    def values(self):
        # Flatten the table and return all values
        return [value for bucket in self.table.values() for key, value in bucket]

    def items(self):
        # Flatten the table and return all key-value pairs
        return [(key, value) for bucket in self.table.values() for key, value in bucket]

class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, item):
        self.queue.append(item)

    def dequeue(self):
        if self.queue:
            return self.queue.pop(0)
        return None

    def is_empty(self):
        return len(self.queue) == 0

    def peek(self):
        if self.queue:
            return self.queue[0]
        return None

class PriorityQueue(MinHeap):
    def __init__(self):
        super().__init__()

    def push(self, priority, item):
        super().push((priority, item))

    def pop(self):
        return super().pop()[1] if self.heap else None

    def peek(self):
        return self.heap[0][1] if self.heap else None

class AVLTree:
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.value = value
            self.height = 1
            self.left = None
            self.right = None

    def __init__(self):
        self.root = None

    # Implement AVL Tree methods (insert, delete, rotate, balance) as needed

# Additional data structures can be added here if necessary for the project requirements.


MAP_ISLAMABAD.py

from data_structures import Graph

# Dictionary of locations with their coordinates (x, y)
LOCATIONS = {
    # Sectors
    'F-6 Markaz': (0, 0),
    'F-7 Markaz': (2, 1),
    'G-9 Markaz': (-2, 3),
    'I-8 Markaz': (-4, 5),
    'E-11 Markaz': (-3, -2),
    'F-10 Markaz': (1, 3),
    'G-11 Markaz': (-1, 4),
    'F-17': (5, 7),
    'E-11': (-3, -3),
    'G-10': (0, 4),
    'D-12': (-5, -1),
    'F-11': (2, 4),
    'G-6': (-1, 1),
    
    # Universities
    'QAU': (6, 2),
    'IIUI': (-6, 6),
    'Air University': (3, 5),
    'FAST University': (1, 2),
    'COMSATS': (4, 3),
    'NUST': (-2, 6),
    
    # Landmarks
    'Faisal Mosque': (0, 5),
    'Shakarparian': (3, -1),
    'Pakistan Monument': (2, -2),
    'Daman-e-Koh': (1, 6),
    'Lok Virsa Museum': (4, -2),
    'Centaurus Mall': (2, 0),
    'Serena Hotel': (1, 1)
}

# Dictionary of direct distances between connected locations
DISTANCES = {
    # Major connections between sectors
    ('F-6 Markaz', 'F-7 Markaz'): 3,
    ('F-7 Markaz', 'F-10 Markaz'): 4,
    ('F-10 Markaz', 'F-11'): 2,
    ('G-9 Markaz', 'G-10'): 2,
    ('G-10', 'G-11 Markaz'): 3,
    ('E-11 Markaz', 'E-11'): 1,
    ('I-8 Markaz', 'G-9 Markaz'): 5,
    
    # Connections to universities
    ('F-7 Markaz', 'FAST University'): 3,
    ('G-11 Markaz', 'NUST'): 4,
    ('F-10 Markaz', 'Air University'): 4,
    ('G-9 Markaz', 'COMSATS'): 6,
    ('E-11', 'IIUI'): 8,
    
    # Connections to landmarks
    ('F-7 Markaz', 'Centaurus Mall'): 2,
    ('F-6 Markaz', 'Serena Hotel'): 2,
    ('G-10', 'Faisal Mosque'): 3,
    ('F-11', 'Daman-e-Koh'): 4,
    ('F-7 Markaz', 'Pakistan Monument'): 4,
    ('F-6 Markaz', 'Shakarparian'): 5,
    
    # Additional strategic connections
    ('G-6', 'F-6 Markaz'): 2,
    ('G-6', 'G-9 Markaz'): 4,
    ('F-10 Markaz', 'G-10'): 2,
    ('F-11', 'E-11'): 5,
    ('D-12', 'E-11'): 3,
    ('F-17', 'Air University'): 4
}

class IslamabadMap:
    def __init__(self):
        self.graph = Graph()
        self._initialize_map()
    
    def _initialize_map(self):
        # Add all locations as nodes
        for location in LOCATIONS:
            self.graph.add_node(location)
        
        # Add all connections with distances
        # Add both directions since it's an undirected graph
        for (start, end), distance in DISTANCES.items():
            self.graph.add_edge(start, end, distance)
    
    def get_location_coordinates(self, location):
        """Get the coordinates of a specific location."""
        return LOCATIONS.get(location)
    
    def get_direct_distance(self, start, end):
        """Get the direct distance between two locations if they're directly connected."""
        return DISTANCES.get((start, end)) or DISTANCES.get((end, start))
    
    def get_shortest_path_distance(self, start, end):
        """Calculate the shortest path distance between any two locations."""
        if start not in LOCATIONS or end not in LOCATIONS:
            return None
        distances = self.graph.dijkstra(start)
        return distances[end]
    
    def get_nearby_locations(self, location, max_distance):
        """Get all locations within a specified distance of a given location."""
        if location not in LOCATIONS:
            return []
        distances = self.graph.dijkstra(location)
        return [loc for loc, dist in distances.items() if 0 < dist <= max_distance]
    
    def get_all_locations(self):
        """Return a list of all locations in the map."""
        return list(LOCATIONS.keys())
    
    def get_location_type(self, location):
        """Return the type of location (Sector, University, or Landmark)."""
        if location not in LOCATIONS:
            return None
        if 'University' in location or 'NUST' in location or 'QAU' in location or 'IIUI' in location or 'COMSATS' in location:
            return 'University'
        if any(sector in location for sector in ['F-', 'G-', 'I-', 'E-', 'D-']):
            return 'Sector'
        return 'Landmark'

# Helper functions for the map
def is_valid_location(location):
    """Check if a location exists in the map."""
    return location in LOCATIONS

def get_distance_matrix():
    """Generate a complete distance matrix between all locations."""
    map_instance = IslamabadMap()
    locations = list(LOCATIONS.keys())
    matrix = {}
    
    for start in locations:
        matrix[start] = {}
        distances = map_instance.graph.dijkstra(start)
        for end in locations:
            matrix[start][end] = distances[end]
    
    return matrix

# user_management.py
from data_structures import HashTable, DoublyLinkedList
import uuid

class UserManagement:
    def __init__(self):
        self.users = HashTable()  # Store user data
        self.active_sessions = HashTable()  # Track logged-in users
        self.users.load_from_file('users_data.json')
        
    def register_user(self, name, email, phone, password):
        user_id = str(uuid.uuid4())
        user_data = {
            'id': user_id,
            'name': name,
            'email': email,
            'phone': phone,
            'password': password,  # In real system, this should be hashed
            'ride_history': DoublyLinkedList(),
            'active_ride': None
        }
        
        if self.get_user_by_email(email):
            return False, "Email already registered"
            
        self.users.insert(user_id, user_data)
    
        # Save to file immediately
        self.users.save_to_file('users_data.json')
        return True, user_id
    
        
    def login_user(self, email, password):
        for bucket in self.users.table.values():
            if bucket:  # Ensure the bucket is not empty
                for user_id, user_data in bucket:  # Iterate through the list of key-value pairs
                    if user_data['email'] == email and user_data['password'] == password:
                        session_id = str(uuid.uuid4())
                        self.active_sessions.insert(session_id, user_id)
                        return True, session_id
        return False, "Invalid credentials"

        
    def get_user_by_id(self, user_id):
        return self.users.get(user_id)
        
    def get_user_by_email(self, email):
        for user_data in self.users.values():  # Use values() to get all user data
            if user_data['email'] == email:
                return user_data
        return None

    def update_user_profile(self, user_id, updates):
        user_data = self.users.get(user_id)
        if user_data:
            user_data.update(updates)
            self.users.insert(user_id, user_data)
            return True
        return False


# driver_management.py

from data_structures import HashTable, DoublyLinkedList
import uuid
class DriverManagement:
    def __init__(self):
        self.drivers = HashTable()
        self.active_drivers = HashTable()  # Currently available drivers
        self.drivers.load_from_file('drivers_data.json')
        
    def register_driver(self, name, email, phone, password, vehicle_type, license_number):
        driver_id = str(uuid.uuid4())
        driver_data = {
            'id': driver_id,
            'name': name,
            'email': email,
            'phone': phone,
            'password': password,  # Should be hashed in real system
            'vehicle_type': vehicle_type,
            'license_number': license_number,
            'rating': 0.0,
            'total_ratings': 0,
            'current_location': None,
            'active_ride': None,
            'ride_history': DoublyLinkedList()
        }
        
        if self.get_driver_by_email(email):
            return False, "Email already registered"
            
        self.drivers.insert(driver_id, driver_data)
        # Save to file immediately
        self.drivers.save_to_file('drivers_data.json')
        return True, driver_id
        
    def login_driver(self, email, password):
        for bucket in self.drivers.table.values():
            if bucket:  # Ensure the bucket is not empty
                for driver_id, driver_data in bucket:  # Iterate through the list of key-value pairs
                    if driver_data['email'] == email and driver_data['password'] == password:
                        return True, driver_id
        return False, "Invalid credentials"

        
    def update_driver_location(self, driver_id, location):
        driver_data = self.drivers.get(driver_id)
        if driver_data:
            driver_data['current_location'] = location
            self.drivers.insert(driver_id, driver_data)
            return True
        return False
        
    def set_driver_availability(self, driver_id, available):
        if available:
            driver_data = self.drivers.get(driver_id)
            if driver_data and not driver_data['active_ride']:
                self.active_drivers.insert(driver_id, driver_data)
                return True
        else:
            self.active_drivers.delete(driver_id)
            return True
        return False
    
    def get_driver_by_email(self, email):
    # Check if any driver has the given email
        for driver_data_list in self.drivers.table:
            if driver_data_list:  # Ensure there is data in this bucket
                for _, driver in driver_data_list:
                    if driver['email'] == email:
                        return driver
        return None


    def get_available_drivers(self):
        return self.active_drivers.table.values()

    def get_driver_by_id(self, driver_id):
        return self.drivers.get(driver_id)

#ride_request.py
from data_structures import PriorityQueue, Queue

class RideRequest:
    def __init__(self, user_management, driver_management):
        self.user_mgmt = user_management
        self.driver_mgmt = driver_management
        self.normal_requests = Queue()
        self.emergency_requests = PriorityQueue()
        self.active_rides = HashTable()
        
    def request_ride(self, user_id, pickup_location, dropoff_location, is_emergency=False):
        user = self.user_mgmt.get_user_by_id(user_id)
        if not user or user['active_ride']:
            return False, "Invalid user or user already has active ride"
            
        request = {
            'id': str(uuid.uuid4()),
            'user_id': user_id,
            'pickup_location': pickup_location,
            'dropoff_location': dropoff_location,
            'status': 'pending',
            'timestamp': time.time()
        }
        
        if is_emergency:
            self.emergency_requests.push(1, request)  # Priority 1 for emergency
        else:
            self.normal_requests.enqueue(request)
            
        return True, request['id']
        
    def process_ride_requests(self):
        # Process emergency requests first
        while not self.emergency_requests.is_empty():
            request = self.emergency_requests.pop()
            driver = self._find_nearest_driver(request['pickup_location'])
            if driver:
                self._assign_ride(request, driver['id'])
                
        # Process normal requests
        while not self.normal_requests.is_empty():
            request = self.normal_requests.dequeue()
            driver = self._find_nearest_driver(request['pickup_location'])
            if driver:
                self._assign_ride(request, driver['id'])
            else:
                self.normal_requests.enqueue(request)  # Re-queue if no driver found
                
    def _find_nearest_driver(self, pickup_location):
        available_drivers = self.driver_mgmt.get_available_drivers()
        nearest_driver = None
        min_distance = float('inf')
        
        for driver in available_drivers:
            if driver['current_location']:
                distance = self._calculate_distance(pickup_location, driver['current_location'])
                if distance < min_distance:
                    min_distance = distance
                    nearest_driver = driver
                    
        return nearest_driver
        
    def _assign_ride(self, request, driver_id):
        ride_id = str(uuid.uuid4())
        ride_data = {
            'id': ride_id,
            'request': request,
            'driver_id': driver_id,
            'status': 'assigned',
            'start_time': time.time()
        }
        
        self.active_rides.insert(ride_id, ride_data)
        
        # Update user and driver status
        user = self.user_mgmt.get_user_by_id(request['user_id'])
        driver = self.driver_mgmt.get_driver_by_id(driver_id)
        
        user['active_ride'] = ride_id
        driver['active_ride'] = ride_id
        
        self.driver_mgmt.set_driver_availability(driver_id, False)
        
        return ride_id

# rating_system.py
class RatingSystem:
    def __init__(self, driver_management):
        self.driver_mgmt = driver_management
        
    def rate_driver(self, driver_id, rating):
        if rating < 1 or rating > 5:
            return False, "Rating must be between 1 and 5"
            
        driver = self.driver_mgmt.get_driver_by_id(driver_id)
        if not driver:
            return False, "Driver not found"
            
        # Update driver's rating
        total_ratings = driver['total_ratings']
        current_rating = driver['rating']
        
        new_total = total_ratings + 1
        new_rating = ((current_rating * total_ratings) + rating) / new_total
        
        driver['rating'] = round(new_rating, 2)
        driver['total_ratings'] = new_total
        
        self.driver_mgmt.drivers.insert(driver_id, driver)
        return True, driver['rating']
        
    def get_driver_rating(self, driver_id):
        driver = self.driver_mgmt.get_driver_by_id(driver_id)
        if driver:
            return True, {
                'rating': driver['rating'],
                'total_ratings': driver['total_ratings']
            }
        return False, "Driver not found"

# emergency_handler.py
from data_structures import PriorityQueue
import time

class EmergencyHandler:
    def __init__(self, ride_request, location_service, driver_management):
        self.ride_request = ride_request
        self.location_service = location_service
        self.driver_mgmt = driver_management
        self.emergency_requests = PriorityQueue()

    def add_emergency_request(self, user_id, pickup_location, dropoff_location):
        """
        Adds an emergency ride request to the queue with the highest priority.
        Simulates forwarding the request to a 911-like service.
        """
        request = {
            'id': str(uuid.uuid4()),
            'user_id': user_id,
            'pickup_location': pickup_location,
            'dropoff_location': dropoff_location,
            'timestamp': time.time(),
        }
        print(f"Emergency request forwarded to 911 service: {request}")
        self.emergency_requests.push(1, request)  # Priority 1 for emergency requests
        return True, request['id']

    def dispatch_emergency_ride(self):
        """
        Processes the emergency ride queue and dispatches the nearest available emergency vehicle.
        Simulates fetching emergency vehicle location data from a 911-like service.
        """
        if self.emergency_requests.is_empty():
            return False, "No emergency requests in the queue."

        request = self.emergency_requests.pop()
        # Simulate receiving nearest vehicle location from 911 service
        print(f"Fetching nearest emergency vehicle for request: {request['id']}")
        driver = self._find_nearest_driver(request['pickup_location'])

        if driver:
            ride_id = self.ride_request._assign_ride(request, driver['id'])
            return True, f"Emergency ride dispatched. Ride ID: {ride_id}"

        return False, "No available emergency vehicles for dispatch."

    def _find_nearest_driver(self, pickup_location):
        """
        Finds the nearest available driver for the given pickup location.
        Simulates receiving driver data from 911.
        """
        available_drivers = self.driver_mgmt.get_available_drivers()
        print("Available drivers fetched from 911 system.")
        nearest_driver = None
        min_distance = float('inf')

        for driver in available_drivers:
            if driver['current_location']:
                distance = self.location_service.get_shortest_path_distance(pickup_location, driver['current_location'])
                if distance < min_distance:
                    min_distance = distance
                    nearest_driver = driver

        return nearest_driver

# social_rideshare.py
from data_structures import Graph

class SocialRideshare:
    def __init__(self):
        self.user_connections = Graph()  # Graph to represent user connections

    def add_connection(self, user1, user2):
        """
        Establishes a connection between two users for potential ridesharing.
        """
        self.user_connections.add_node(user1)
        self.user_connections.add_node(user2)
        self.user_connections.add_edge(user1, user2, 1)  # Edge weight represents connection strength

    def find_rideshare_partners(self, user, pickup_location, dropoff_location):
        """
        Finds potential rideshare partners based on user connections and route similarity.
        """
        potential_partners = self.user_connections.get_neighbors(user)
        matches = []

        for partner in potential_partners:
            # Here you can add logic to match routes based on similarity (e.g., same path, close destinations).
            matches.append(partner)

        return matches

# ride_history.py
from data_structures import DoublyLinkedList

class RideHistory:
    def __init__(self):
        self.ride_history = DoublyLinkedList()

    def add_ride(self, ride_data):
        """
        Adds a ride record to the user's ride history.
        """
        self.ride_history.append(ride_data)

    def get_ride_history(self):
        """
        Returns the list of all past rides in chronological order.
        """
        history = []
        current = self.ride_history.head
        while current:
            history.append(current.data)
            current = current.next
        return history

# pricing.py
class Pricing:
    def __init__(self, base_rate=10, per_km_rate=5, rideshare_discount=0.2, surge_multiplier=1.0):
        self.base_rate = base_rate
        self.per_km_rate = per_km_rate
        self.rideshare_discount = rideshare_discount
        self.surge_multiplier = surge_multiplier

    def calculate_fare(self, distance, is_rideshare=False, is_peak_time=False):
        """
        Calculates the fare for a given distance, with options for ridesharing and peak time pricing.
        """
        fare = self.base_rate + (distance * self.per_km_rate)
        if is_rideshare:
            fare *= (1 - self.rideshare_discount)
        if is_peak_time:
            fare *= self.surge_multiplier
        return round(fare, 2)

    def split_fare(self, total_fare, num_passengers):
        """
        Splits the fare among rideshare participants.
        """
        if num_passengers <= 0:
            return total_fare
        return round(total_fare / num_passengers, 2)

# location_service.py
from data_structures import Graph
from map_data import IslamabadMap
from map_data import LOCATIONS  # If you need LOCATIONS to get coordinates, etc.

class LocationService:
    def __init__(self, map_data):
        self.graph = Graph()
        self._initialize_map(map_data)

    def _initialize_map(self, map_data):
        """
        Initializes the graph with locations and distances from the map data.
        """
        # Use map_data's method to get all locations
        locations = map_data.get_all_locations()  # This method returns a list of locations
        for location in locations:
            self.graph.add_node(location)

        # Use the global DISTANCES constant
        from map_data import DISTANCES  # Import DISTANCES explicitly if it's not globally available
        for (start, end), distance in DISTANCES.items():  # Now we use DISTANCES directly
            self.graph.add_edge(start, end, distance)

    def get_shortest_path(self, start, end):
        # Implement the method to get the shortest path
        pass

    def get_nearby_locations(self, location, max_distance):
        """
        Gets all locations within a specified distance from the given location.
        """
        distances, _ = self.graph.dijkstra(location)
        return [loc for loc, dist in distances.items() if dist <= max_distance]

    def get_distance_between(self, start, end):
        """
        Returns the direct distance between two connected locations, if available.
        """
        return self.graph.nodes.get(start, {}).get(end, None)

    def is_valid_location(self, location):
        """
        Checks if a location exists in the map.
        """
        return location in self.graph.nodes
import threading
import networkx as nx
import matplotlib.pyplot as plt
from user_management import UserManagement
from driver_management import DriverManagement
from ride_request import RideRequest
from location_service import LocationService
from emergency_handler import EmergencyHandler
from social_rideshare import SocialRideshare
from pricing import Pricing
from ride_history import RideHistory
from map_data import IslamabadMap

# Initialize components
user_mgmt = UserManagement()
driver_mgmt = DriverManagement()
location_service = LocationService(IslamabadMap())
pricing = Pricing()
ride_history = RideHistory()
ride_request = RideRequest(user_mgmt, driver_mgmt)
emergency_handler = EmergencyHandler(ride_request, location_service, driver_mgmt)
social_rideshare = SocialRideshare()

# Visualization of map and rides
def visualize_map():
    G = location_service.graph
    pos = nx.spring_layout(G.nodes)
    nx.draw(G.nodes, pos, with_labels=True, node_color='skyblue', node_size=2000)
    nx.draw_networkx_edges(G.nodes, pos)
    plt.title("Islamabad Ride-Hailing Map")
    plt.show()

def visualize_ride_path(start, end):
    distance, path = location_service.graph.get_shortest_path(start, end)
    if path:
        G = location_service.graph
        pos = nx.spring_layout(G.nodes)
        nx.draw(G.nodes, pos, with_labels=True, node_color='lightgreen', node_size=2000)
        nx.draw_networkx_edges(G.nodes, pos, edgelist=[(path[i], path[i+1]) for i in range(len(path)-1)], edge_color='red', width=2)
        plt.title(f"Ride Path from {start} to {end}")
        plt.show()
    else:
        print("No path found between the selected locations.")

# User options
def user_dashboard(user_id):
    while True:
        print("\n--- User Dashboard ---")
        print("1. Request Ride")
        print("2. View Ride History")
        print("3. Select Location")
        print("4. Book Emergency Ride")
        print("5. View Rideshare Connections")
        print("6. Add Rideshare Connection")
        print("7. Visualize Map")
        print("8. Logout")

        choice = input("Enter your choice: ")

        if choice == '1':
            pickup = input("Enter pickup location: ")
            destination = input("Enter destination: ")
            if location_service.is_valid_location(pickup) and location_service.is_valid_location(destination):
                success, ride_id = ride_request.request_ride(user_id, pickup, destination)
                if success:
                    print("Ride requested successfully. Ride ID:", ride_id)
                    visualize_ride_path(pickup, destination)
                else:
                    print("Failed to request ride.")
            else:
                print("Invalid locations.")
        elif choice == '2':
            history = ride_history.get_ride_history()
            print("--- Ride History ---")
            for ride in history:
                print(ride)
        elif choice == '3':
            location = input("Select your current location: ")
            if location_service.is_valid_location(location):
                user_mgmt.update_user_profile(user_id, {'location': location})
                print("Location updated.")
            else:
                print("Invalid location.")
        elif choice == '4':
            pickup = input("Enter pickup location: ")
            destination = input("Enter emergency destination: ")
            success, ride_id = emergency_handler.add_emergency_request(user_id, pickup, destination)
            if success:
                print("Emergency ride booked. Ride ID:", ride_id)
                visualize_ride_path(pickup, destination)
            else:
                print("Failed to book emergency ride.")
        elif choice == '5':
            connections = social_rideshare.find_rideshare_partners(user_id, "", "")
            print("Potential rideshare partners:", connections)
        elif choice == '6':
            friend_id = input("Enter the ID of the friend to add as rideshare connection: ")
            social_rideshare.add_connection(user_id, friend_id)
            print("Rideshare connection added successfully.")
        elif choice == '7':
            visualize_map()
        elif choice == '8':
            print("Logging out...")
            break
        else:
            print("Invalid choice. Please try again.")

# Driver options
def driver_dashboard(driver_id):
    while True:
        print("\n--- Driver Dashboard ---")
        print("1. Toggle Availability")
        print("2. View Ride History")
        print("3. Update Location")
        print("4. Visualize Map")
        print("5. Logout")

        choice = input("Enter your choice: ")

        if choice == '1':
            status = input("Enter 'on' to be available or 'off' to go offline: ").lower()
            available = status == 'on'
            driver_mgmt.set_driver_availability(driver_id, available)
            print("Availability updated.")
        elif choice == '2':
            history = ride_history.get_ride_history()
            print("--- Ride History ---")
            for ride in history:
                print(ride)
        elif choice == '3':
            location = input("Enter your current location: ")
            if location_service.is_valid_location(location):
                driver_mgmt.update_driver_location(driver_id, location)
                print("Location updated.")
            else:
                print("Invalid location.")
        elif choice == '4':
            visualize_map()
        elif choice == '5':
            print("Logging out...")
            break
        else:
            print("Invalid choice. Please try again.")

def main():
    while True:
    # Load existing data
        user_mgmt.users.load_from_file('users_data.json')
        driver_mgmt.drivers.load_from_file('drivers_data.json')

def run_user_login():
    print("\n--- User Login ---")
    email = input("Enter email: ")
    password = input("Enter password: ")

    success, result = user_mgmt.login_user(email, password)
    if success:
        session_id = result
        print("Login successful!")
        user_dashboard(session_id)  # Pass session_id to access the dashboard
    else:

        print(result)  # Print error message from login failure

def run_driver_login():
    print("\n--- Driver Login ---")
    email = input("Enter email: ")
    password = input("Enter password: ")

    success, result = driver_mgmt.login_driver(email, password)
    if success:
        driver_id = result
        print("Login successful!")
        driver_dashboard(driver_id)  # Pass driver_id to access the dashboard
    else:
        print(result)  # Print error message from login failure

def run_user_signup():
    print("\n--- User Signup ---")
    name = input("Enter your name: ")
    email = input("Enter email: ")
    phone = input("Enter phone number: ")
    password = input("Enter password: ")

    success, result = user_mgmt.register_user(name, email, phone, password)
    if success:
        print(f"Signup successful! Your user ID is {result}")
        run_user_login()  # After successful signup, redirect to login
    else:
        print(result)  # Print error message from signup failure
        

def run_driver_signup():
    print("\n--- Driver Signup ---")
    name = input("Enter your name: ")
    email = input("Enter email: ")
    phone = input("Enter phone number: ")
    password = input("Enter password: ")
    vehicle_type = input("Enter vehicle type: ")
    license_number = input("Enter license number: ")

    success, result = driver_mgmt.register_driver(name, email, phone, password, vehicle_type, license_number)
    if success:
        print(f"Signup successful! Your driver ID is {result}")
        run_driver_login()  # After successful signup, redirect to login
    else:
        print(result)  # Print error message from signup failure

def main():
    while True:
        print("\n--- Main Menu ---")
        print("1. User Login")
        print("2. Driver Login")
        print("3. User Signup")
        print("4. Driver Signup")
        print("5. Exit")
        
        choice = input("Enter your choice: ")
        
        if choice == '1':
            run_user_login()
        elif choice == '2':
            run_driver_login()
        elif choice == '3':
            run_user_signup()
        elif choice == '4':
            run_driver_signup()
        elif choice == '5':
            break
        else:
            print("Invalid choice. Please try again.")
    

if __name__ == "__main__":
    main()

