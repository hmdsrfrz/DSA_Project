#location_service.py
from data_structures import Graph
from map_data import IslamabadMap
from save_load import save_data_to_file, load_data_from_file

class LocationService:
    def __init__(self, map_data: IslamabadMap, file_path='location_service.json'):
        self.map_data = map_data  
        self.file_path = file_path
        self.graph = load_data_from_file(self.file_path, Graph)
        if not self.graph:
            self.graph = Graph()
            self._initialize_map()
            save_data_to_file(self.file_path, self.graph)

    def _initialize_map(self):
        """
        Initializes the graph with locations and distances from the IslamabadMap instance.
        """
        # Add all locations as nodes
        locations = self.map_data.get_all_locations()
        for location in locations:
            self.graph.add_node(location)

        # Add all distances as edges
        distances = self.map_data.get_distances()  # Use the get_distances method
        for (start, end), distance in distances.items():
            self.graph.add_edge(start, end, distance)
            # Add reverse direction since roads are typically bidirectional
            self.graph.add_edge(end, start, distance)
        
        return self.graph

    def get_shortest_path(self, start, end):
        """Get the shortest path and its distance between two locations."""
        if not self.is_valid_location(start) or not self.is_valid_location(end):
            return None, "Invalid locations provided."
        
        try:
            distances, previous_nodes = self.graph.dijkstra_with_path(start)
            if distances[end] == float('inf'):
                return None, "No path exists between the specified locations."
            
            # Reconstruct path
            path = []
            current = end
            while current:
                path.insert(0, current)
                current = previous_nodes.get(current)
                
            return path, distances[end]
        except Exception as e:
            return None, f"Error calculating path: {str(e)}"

    def get_nearby_locations(self, location, max_distance):
        """Gets all locations within a specified distance from the given location."""
        if not self.is_valid_location(location):
            return []
        
        try:
            distances, _ = self.graph.dijkstra(location)
            return [loc for loc, dist in distances.items() if 0 < dist <= max_distance]
        except Exception:
            return []

    def get_distance_between(self, start, end):
        """Returns the shortest path distance between two locations."""
        if not self.is_valid_location(start) or not self.is_valid_location(end):
            return None
            
        try:
            distances, _ = self.graph.dijkstra(start)
            distance = distances.get(end)
            return None if distance == float('inf') else distance
        except Exception:
            return None

    def is_valid_location(self, location):
        """Checks if a location exists in the map."""
        return location in self.graph.nodes

    def save(self):
        """Save the current state of the graph."""
        save_data_to_file(self.graph, self.file_path)

#map_data.py
from data_structures import Graph
from save_load import save_data_to_file, load_data_from_file

# Dictionary of locations with their coordinates (x, y)
LOCATIONS = {
    # Sectors
    'F-6 Markaz': (0, 0),
    'F-7 Markaz': (2, 1),
    'G-9 Markaz': (-2, 3),
    'I-8 Markaz': (-4, 5),
    'E-11 Markaz': (-3, -2),
    'F-10 Markaz': (1, 3),
    'G-11 Markaz': (-1, 4),
    'F-17': (5, 7),
    'E-11': (-3, -3),
    'G-10': (0, 4),
    'D-12': (-5, -1),
    'F-11': (2, 4),
    'G-6': (-1, 1),

    # Universities
    'IIUI': (-6, 6),
    'Air University': (3, 5),
    'FAST University': (1, 2),
    'COMSATS': (4, 3),
    'NUST': (-2, 6),

    # Landmarks
    'Faisal Mosque': (0, 5),
    'Shakarparian': (3, -1),
    'Pakistan Monument': (2, -2),
    'Daman-e-Koh': (1, 6),
    'Centaurus Mall': (2, 0),
    'Serena Hotel': (1, 1)
}

# Dictionary of direct distances between connected locations
DISTANCES = {
    # Major connections between sectors
    ('F-6 Markaz', 'F-7 Markaz'): 3,
    ('F-7 Markaz', 'F-10 Markaz'): 4,
    ('F-10 Markaz', 'F-11'): 2,
    ('G-9 Markaz', 'G-10'): 2,
    ('G-10', 'G-11 Markaz'): 3,
    ('E-11 Markaz', 'E-11'): 1,
    ('I-8 Markaz', 'G-9 Markaz'): 5,

    # Connections to universities
    ('F-7 Markaz', 'FAST University'): 3,
    ('G-11 Markaz', 'NUST'): 4,
    ('F-10 Markaz', 'Air University'): 4,
    ('G-9 Markaz', 'COMSATS'): 6,
    ('E-11', 'IIUI'): 8,

    # Connections to landmarks
    ('F-7 Markaz', 'Centaurus Mall'): 2,
    ('F-6 Markaz', 'Serena Hotel'): 2,
    ('G-10', 'Faisal Mosque'): 3,
    ('F-11', 'Daman-e-Koh'): 4,
    ('F-7 Markaz', 'Pakistan Monument'): 4,
    ('F-6 Markaz', 'Shakarparian'): 5,

    # Additional strategic connections
    ('G-6', 'F-6 Markaz'): 2,
    ('G-6', 'G-9 Markaz'): 4,
    ('F-10 Markaz', 'G-10'): 2,
    ('F-11', 'E-11'): 5,
    ('D-12', 'E-11'): 3,
    ('F-17', 'Air University'): 4
}

class IslamabadMap:
    def __init__(self, file_path='map_data.json'):
        self.file_path = file_path
        self.graph = load_data_from_file(self.file_path, Graph) or self._initialize_map()
        self.locations = LOCATIONS  # Dictionary of locations and their coordinates
        self.distances = DISTANCES  # Dictionary of distances between locations

    def _initialize_map(self):
        """Initialize the map graph with locations and distances."""
        graph = Graph()
        for location in LOCATIONS:
            graph.add_node(location)
        for (start, end), distance in DISTANCES.items():
            graph.add_edge(start, end, distance)
            graph.add_edge(end, start, distance)  # Add reverse direction
        save_data_to_file(self.file_path, graph)
        return graph

    def get_location_coordinates(self, location):
        """Get the coordinates of a specific location."""
        return LOCATIONS.get(location)

    def get_direct_distance(self, start, end):
        """Get the direct distance between two locations if they're directly connected."""
        return DISTANCES.get((start, end)) or DISTANCES.get((end, start))

    def get_shortest_path(self, start, end):
            """Delegate shortest path calculation to the graph."""
            return self.graph.get_shortest_path(start, end)


    def get_nearby_locations(self, location, max_distance):
        """Get all locations within a specified distance of a given location."""
        if location not in LOCATIONS:
            return []
        distances, _ = self.graph.dijkstra(location)
        return [loc for loc, dist in distances.items() if 0 < dist <= max_distance]

    def get_all_locations(self):
        """Return a list of all locations in the map."""
        return list(LOCATIONS.keys())

    def get_location_type(self, location):
        """Return the type of location (Sector, University, or Landmark)."""
        if location not in LOCATIONS:
            return None
        if 'University' in location or 'NUST' in location or 'IIUI' in location or 'COMSATS' in location:
            return 'University'
        if any(sector in location for sector in ['F-', 'G-', 'I-', 'E-', 'D-']):
            return 'Sector'
        return 'Landmark'

    def get_distances(self):
        """Return all distances between connected locations."""
        return self.distances

# Helper functions for the map
def is_valid_location(location):
    """Check if a location exists in the map."""
    return location in LOCATIONS

def get_distance_matrix():
    """Generate a complete distance matrix between all locations."""
    map_instance = IslamabadMap()
    locations = list(LOCATIONS.keys())
    matrix = {}

    for start in locations:
        matrix[start] = {}
        distances, _ = map_instance.graph.dijkstra(start)
        for end in locations:
            matrix[start][end] = distances.get(end, float('inf'))

    return matrix

#map_visualization.py

import networkx as nx
import matplotlib.pyplot as plt


# Then modify the visualize_map function in map_visualization.py
def visualize_map(location_service):
    """
    Visualizes the map using the graph data from the location service.
    """
    G = nx.Graph()

    # Add nodes
    locations = location_service.map_data.get_all_locations()
    for location in locations:
        G.add_node(location)

    # Add edges with weights from DISTANCES dictionary
    distances = location_service.map_data.get_distances()
    for (start, end), distance in distances.items():
        G.add_edge(start, end, weight=distance)

    # Visualization
    pos = nx.spring_layout(G)
    plt.figure(figsize=(12, 8))
    plt.gca().set_facecolor('black')

    nx.draw(
        G, pos,
        with_labels=True,
        node_color='lightgrey',
        edge_color='red',
        font_color='white',
        node_size=2000,
        font_size=8,
        font_weight='bold'
    )

    # Draw edge labels
    edge_labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='white')

    plt.title("Islamabad Ride-Hailing Map", color='white', fontsize=14, pad=20)
    plt.show()

def visualize_ride_path(location_service, start, end):
    distance, path = location_service.get_shortest_path(start, end)
    if path:
        G = nx.Graph()
        for location in location_service.map_data.get_all_locations():
            G.add_node(location)

        for (start_node, end_node), dist in location_service.map_data.get_distances().items():
            G.add_edge(start_node, end_node, weight=dist)

        pos = nx.spring_layout(G)
        nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=2000, font_size=10)
        path_edges = [(path[i], path[i + 1]) for i in range(len(path) - 1)]
        nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='red', width=2)

        labels = nx.get_edge_attributes(G, 'weight')
        nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

        plt.title(f"Ride Path from {start} to {end} (Distance: {distance})")
        plt.show()
    else:
        print("No path found between the selected locations.")


