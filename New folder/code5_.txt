import threading
import time
import os
import networkx as nx
import matplotlib.pyplot as plt
import sys

sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from user_management import UserManagement
from driver_management import DriverManagement
from ride_request import RideRequest
from location_service import LocationService
from emergency_handler import EmergencyHandler
from social_rideshare import SocialRideshare
from pricing import Pricing
from ride_history import RideHistory
from map_data import IslamabadMap, is_valid_location, LOCATIONS
from data_structures import Graph, HashTable
from map_visualization import visualize_map, visualize_ride_path
from friend_management import FriendManagement


class Dashboards:
    def __init__(self, user_mgmt, driver_mgmt, ride_request, location_service, pricing, ride_history, emergency_handler, friend_mgmt):
        self.user_mgmt = user_mgmt
        self.driver_mgmt = driver_mgmt
        self.ride_request = ride_request
        self.location_service = location_service
        self.pricing = pricing
        self.ride_history = ride_history
        self.emergency_handler = emergency_handler
        self.friend_mgmt = friend_mgmt

    def run_user_login(self):
        print("\n--- User Login ---")
        email = input("Enter email: ")
        password = input("Enter password: ")

        success, result = self.user_mgmt.login_user(email, password)
        if success:
            session_id = result
            print("Login successful!")
            print("Session ID after login:", session_id)
            self.user_dashboard(session_id)  # Pass session_id to access the dashboard
        else:
            print(result)  # Print error message from login failure

    def run_user_signup(self):
        print("\n--- User Signup ---")
        name = input("Enter your name: ")
        email = input("Enter email: ")
        phone = input("Enter phone number: ")
        password = input("Enter password: ")

        success, result = self.user_mgmt.register_user(name, email, phone, password)
        if success:
            self.user_mgmt.users.save_to_file('users_data.json')
            print(f"Signup successful! Your user ID is {result}")
            self.run_user_login()  # After successful signup, redirect to login
        else:
            print(result)  # Print error message from signup failure

    def user_dashboard(self, user_id):
        '''user_id = self.user_mgmt.get_user_by_session(user_id)
        if not user_id:
                print("Error: User ID not found for session.")
                return'''
        
        print("User ID in Dashboard:", user_id)
        while True:
            updates = self.ride_request.get_user_updates(user_id)
            if updates:
                if updates['type'] == 'ride_accepted':
                    print(f"\nRide accepted by driver {updates['driver']['name']}!")
                    print(f"Driver phone: {updates['driver']['phone']}")
                    print(f"Vehicle type: {updates['driver']['vehicle_type']}")

            print("\n--- User Dashboard ---")
            print("1. Request Ride")
            print("2. View Ride History")
            print("3. Select Location")
            print("4. Book Emergency Ride")
            print("5. View Friends")
            print("6. Add Friend")
            print("7. View Friend Requests")
            print("8. Visualize Map")
            print("9. Logout")
            print("10. See available drivers")

            choice = input("Enter your choice: ")

            if choice == '1':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                try:
                    # Prompt the user to select pickup and destination locations
                    pickup_index = int(input("Enter the number for your pickup location: "))
                    destination_index = int(input("Enter the number for your destination: "))

                    # Validate user input
                    if pickup_index < 1 or pickup_index > len(all_locations) or destination_index < 1 or destination_index > len(all_locations):
                        print("Invalid selection. Please choose valid location numbers.")
                        continue  # Continue to the next iteration of the loop

                    pickup = all_locations[pickup_index - 1]
                    destination = all_locations[destination_index - 1]

                    # Ensure pickup and destination are not the same
                    if pickup == destination:
                        print("Pickup and destination locations cannot be the same. Please try again.")
                        continue  # Continue to the next iteration of the loop

                    # Validate the locations and proceed with the ride request
                    if is_valid_location(pickup) and is_valid_location(destination):
                        success, ride_id = self.ride_request.request_ride(user_id, pickup, destination)
                        if success:
                            print("Ride requested successfully. Ride ID:", ride_id)
                            visualize_ride_path(islamabad_map, pickup, destination)
                        else:
                            print("Failed to request ride.")
                    else:
                        print("Invalid locations. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter numbers corresponding to the locations.")

            elif choice == '2':
                history = self.ride_history.get_ride_history()
                print("--- Ride History ---")
                for ride in history:
                    print(ride)
            elif choice == '3':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                location = input("Select your current location: ")

                # Validate the location using IslamabadMap
                if is_valid_location(location):
                    self.user_mgmt.update_user_profile(user_id, {'location': location})
                    print("Location updated.")
                else:
                    print("Invalid location. Please select a valid location from the available options.")

            elif choice == '4':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                try:
                    # Prompt the user to select pickup and destination locations
                    pickup_index = int(input("Enter the number for your pickup location: "))
                    destination_index = int(input("Enter the number for your emergency destination: "))

                    # Validate user input
                    if pickup_index < 1 or pickup_index > len(all_locations) or destination_index < 1 or destination_index > len(all_locations):
                        print("Invalid selection. Please choose valid location numbers.")
                        continue  # Continue to the next iteration of the loop

                    pickup = all_locations[pickup_index - 1]
                    destination = all_locations[destination_index - 1]

                    # Ensure pickup and destination are not the same
                    if pickup == destination:
                        print("Pickup and destination locations cannot be the same. Please try again.")
                        continue  # Continue to the next iteration of the loop

                    # Validate the locations and proceed with the emergency request
                    if is_valid_location(pickup) and is_valid_location(destination):
                        success, ride_id = self.emergency_handler.add_emergency_request(user_id, pickup, destination)
                        if success:
                            print("Emergency ride booked successfully. Ride ID:", ride_id)
                            visualize_ride_path(islamabad_map, pickup, destination)
                        else:
                            print("Failed to book emergency ride.")
                    else:
                        print("Invalid locations. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter numbers corresponding to the locations.")

            elif choice == '5':
                friends = self.friend_mgmt.get_friends_list(user_id)
                print("\n--- Your Friends ---")
                for idx, (friend_id, friend_data) in enumerate(friends, 1):
                    print(f"{idx}. {friend_data['name']} ({friend_data['email']})")

            elif choice == '6':
                users = self.friend_mgmt.display_all_users()
                if users:
                    choice = input("\nEnter the number of the user to add: ")
                    try:
                        idx = int(choice)
                        success, message = self.friend_mgmt.send_friend_request(user_id, idx, users)
                        print(message)
                    except ValueError:
                        print("Invalid input")

            elif choice == '7':
                pending_requests = self.friend_mgmt.get_pending_requests(user_id)
                if not pending_requests:
                    print("No pending friend requests")
                else:
                    print("\n--- Pending Friend Requests ---")
                    for idx, (from_id, from_user) in enumerate(pending_requests, 1):
                        print(f"{idx}. {from_user['name']} ({from_user['email']})")
                    choice = input("\nEnter request number to accept (or 0 to skip): ")
                    try:
                        idx = int(choice)
                        if idx > 0:
                            success, message = self.friend_mgmt.accept_friend_request(
                                user_id, idx, pending_requests)
                            print(message)
                    except ValueError:
                        print("Invalid input")
            elif choice == '8':
                visualize_map(self.location_service)
            elif choice == '10':
                 self.see_available_drivers()
            elif choice == '9':
                print("Logging out...")
                break
            else:
                print("Invalid choice. Please try again.")

    def see_available_drivers(self):
        print("\n--- Available Drivers ---")
        available_drivers = self.driver_mgmt.get_available_drivers()
        if not available_drivers:
            print("No drivers are currently available.")
            return

        for idx, driver in enumerate(available_drivers, 1):
            print(f"\nDriver {idx}:")
            print(f"Name: {driver['name']}")
            print(f"Vehicle Type: {driver['vehicle_type']}")
            print(f"Current Location: {driver.get('current_location', 'Unknown')}")
            print(f"Availability: {driver.get('availability', 'Not Set')}")


    def run_driver_login(self):
        print("\n--- Driver Login ---")
        email = input("Enter email: ")
        password = input("Enter password: ")

        success, result = self.driver_mgmt.login_driver(email, password)
        if success:
            driver_id = result
            print("Login successful!")
            self.driver_dashboard(driver_id)  # Pass driver_id to access the dashboard
        else:
            print(result)  # Print error message from login failure

    def run_driver_signup(self):
        print("\n--- Driver Signup ---")
        name = input("Enter your name: ")
        email = input("Enter email: ")
        phone = input("Enter phone number: ")
        password = input("Enter password: ")
        vehicle_type = input("Enter vehicle type: ")
        license_number = input("Enter license number: ")

        success, result = self.driver_mgmt.register_driver(name, email, phone, password, vehicle_type, license_number)
        if success:
            self.driver_mgmt.drivers.save_to_file('drivers_data.json')
            print(f"Signup successful! Your driver ID is {result}")
            self.run_driver_login()  # After successful signup, redirect to login
        else:
            print(result)  # Print error message from signup failure

    

    def driver_dashboard(self, driver_id):
        while True:
            print("\n--- Driver Dashboard ---")
            print("1. Toggle Availability")
            print("2. View Ride History")
            print("3. Update Location")
            print("4. View Available Requests")
            print("5. Complete Ride")
            print("6. Visualize Map")
            print("7. Logout")
            print("8. See available drivers")

            choice = input("Enter your choice: ")

            if choice == '1':
                status = input("Enter 'on' to be available or 'off' to go offline: ").lower()
                available = status == 'on'
                self.driver_mgmt.set_driver_availability(driver_id, available)
                print("Availability updated.")
            elif choice == '2':
                history = self.ride_history.get_ride_history()
                print("--- Ride History ---")
                for ride in history:
                    print(ride)
            elif choice == '3':
                # Create an instance of IslamabadMap
                islamabad_map = IslamabadMap()
                all_locations = islamabad_map.get_all_locations()

                print("\n--- Available Locations ---")
                for idx, location in enumerate(all_locations, start=1):
                    print(f"{idx}. {location}")

                try:
                    # Prompt the driver to select their current location
                    location_index = int(input("Enter the number for your current location: "))

                    # Validate user input
                    if location_index < 1 or location_index > len(all_locations):
                        print("Invalid selection. Please choose a valid location number.")
                        continue  # Continue to the next iteration of the loop

                    location = all_locations[location_index - 1]

                    # Validate the location and update the driver's location
                    if is_valid_location(location):
                        self.driver_mgmt.update_driver_location(driver_id, location)
                        print("Location updated.")
                    else:
                        print("Invalid location. Please try again.")
                except ValueError:
                    print("Invalid input. Please enter a number corresponding to the locations.")

            elif choice == '4':
                # Ensure driver location is updated
                driver = self.driver_mgmt.get_driver_by_id(driver_id)
                if not driver['current_location']:
                    print("Please update your location first.")
                    continue

                # Call the view_ride_requests function to display and handle requests
                DriverManagement.view_ride_requests(driver_id)

            elif choice == '5':
                driver = self.driver_mgmt.get_driver_by_id(driver_id)
                if not driver['active_ride']:
                    print("You don't have any active rides.")
                    continue

                ride_id = driver['active_ride']
                success, message = self.ride_request.complete_ride(ride_id)
                print(message)

            elif choice == '6':
                visualize_map(self.location_service)

            elif choice == '7':
                print("Logging out...")

            elif choice == '8':
                 self.see_available_drivers()
                 break

            else:
                print("Invalid choice. Please try again.")#data_structures.py
import json
from save_load import save_data_to_file, load_data_from_file

class MinHeap:
    def __init__(self):
        self.heap = []

    def push(self, item):
        self.heap.append(item)
        self._heapify_up(len(self.heap) - 1)

    def pop(self):
        if len(self.heap) == 0:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()
        root = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)
        return root

    def _heapify_up(self, index):
        parent = (index - 1) // 2
        if index > 0 and self.heap[index] < self.heap[parent]:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            self._heapify_up(parent)

    def _heapify_down(self, index):
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        if left < len(self.heap) and self.heap[left] < self.heap[smallest]:
            smallest = left
        if right < len(self.heap) and self.heap[right] < self.heap[smallest]:
            smallest = right
        if smallest != index:
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
            self._heapify_down(smallest)

    def peek(self):
        if self.heap:
            return self.heap[0]
        return None
    def is_empty(self):
        return len(self.heap) == 0

    def size(self):
        return len(self.heap)



class Graph:
    def __init__(self):
        self.nodes = {}

    def add_node(self, location):
        if location not in self.nodes:
            self.nodes[location] = {}

    def add_edge(self, start, end, distance):
        if start in self.nodes and end in self.nodes:
            self.nodes[start][end] = distance
            self.nodes[end][start] = distance  # Since it's an undirected graph

    def get_neighbors(self, node):
        return self.nodes.get(node, {})

    def dijkstra(self, start):
        """
        Implementation of Dijkstra's shortest path algorithm using MinHeap.
        
        Args:
            start: Starting node
            
        Returns:
            Dictionary of shortest distances to all nodes from start node
            Dictionary of previous nodes in the shortest path
        """
        # Initialize distances with infinity for all nodes except start
        distances = {node: float('infinity') for node in self.nodes}
        distances[start] = 0
        
        # Dictionary to store the previous node in shortest path
        previous = {node: None for node in self.nodes}
        
        # Create min heap for storing vertices to visit
        pq = MinHeap()
        pq.push((0, start))  # (distance, node)
        
        # Set to keep track of visited nodes
        visited = set()
        
        while not pq.is_empty():
            # Get the node with minimum distance
            current_distance, current_node = pq.pop()
            
            # If we've already processed this node, skip it
            if current_node in visited:
                continue
                
            # Mark node as visited
            visited.add(current_node)
            
            # If current distance is greater than known distance, skip
            if current_distance > distances[current_node]:
                continue
            
            # Check all neighbors of current node
            for neighbor, weight in self.nodes[current_node].items():
                # Skip if neighbor is already visited
                if neighbor in visited:
                    continue
                    
                # Calculate tentative distance to neighbor
                distance = current_distance + weight
                
                # If we found a shorter path, update it
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_node
                    pq.push((distance, neighbor))
        
        return distances, previous

    def get_shortest_path(self, start, end):
        """
        Gets the shortest path between start and end nodes.
        
        Args:
            start: Starting node
            end: Ending node
            
        Returns:
            tuple: (path_distance, path_nodes)
            where path_distance is the total distance
            and path_nodes is a list of nodes in the path
        """
        # Get shortest distances and previous nodes
        distances, previous = self.dijkstra(start)
        
        if distances[end] == float('infinity'):
            return None, None  # No path exists
            
        # Reconstruct the path
        path = []
        current = end
        
        while current is not None:
            path.append(current)
            current = previous[current]
            
        # Reverse path to get it from start to end
        path.reverse()
        
        return distances[end], path
    

    def get_shortest_path_distance(self, start, end):
        if start not in self.nodes or end not in self.nodes:
            return None
        distances, _ = self.dijkstra(start)
        return distances.get(end, float('inf'))



    def get_all_paths(self, start):
        """
        Gets all shortest paths from start node to all other nodes.
        
        Args:
            start: Starting node
            
        Returns:
            Dictionary with end nodes as keys and (distance, path) tuples as values
        """
        distances, previous = self.dijkstra(start)
        paths = {}
        
        for end in self.nodes:
            if end == start:
                paths[end] = (0, [start])
                continue
                
            if distances[end] == float('infinity'):
                paths[end] = (None, None)
                continue
                
            # Reconstruct path
            path = []
            current = end
            while current is not None:
                path.append(current)
                current = previous[current]
            path.reverse()
            
            paths[end] = (distances[end], path)
            
        return paths
    
    def to_dict(self):
        """
        Converts the Graph into a dictionary for serialization.
        """
        return {"nodes": self.nodes}

    @classmethod
    def from_dict(cls, data):
        """
        Reconstructs a Graph from a dictionary.
        """
        new_graph = cls()
        new_graph.nodes = data.get("nodes", {})
        return new_graph

class DoublyLinkedList:
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None
            self.prev = None

    def __init__(self):
        self.head = None
        self.tail = None

    def to_list(self):
        """Convert the linked list into a list."""
        result = []
        current = self.head
        while current:
            result.append(current.data)  # Assuming each node has a 'data' attribute
            current = current.next
        return result

    @classmethod
    def from_list(cls, data_list):
        """Reconstruct the linked list from a list."""
        new_list = cls()
        for item in data_list:
            new_list.append(item)  # Assuming an `append` method exists
        return new_list

    def append(self, data):
        new_node = self.Node(data)
        if not self.head:
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def traverse_forward(self):
        current = self.head
        while current:
            print(current.data)
            current = current.next

    def traverse_backward(self):
        current = self.tail
        while current:
            print(current.data)
            current = current.prev

    def to_list(self):
        """
        Converts the DoublyLinkedList into a standard Python list.
        """
        result = []
        current = self.head
        while current:
            result.append(current.data)  # Assuming each node has a 'data' attribute
            current = current.next
        return result

    @classmethod
    def from_list(cls, data_list):
        """
        Creates a DoublyLinkedList from a standard Python list.
        """
        new_list = cls()
        for item in data_list:
            new_list.append(item)  # Assuming an `append` method exists
        return new_list
    
    def delete(self, data):
        current = self.head
        while current:
            if current.data == data:
                if current.prev:
                    current.prev.next = current.next
                if current.next:
                    current.next.prev = current.prev
                if current == self.head:
                    self.head = current.next
                if current == self.tail:
                    self.tail = current.prev
                return
            current = current.next

class HashTable:
    def __init__(self, size=10):  # Initialize with a default size
        self.table = {}  # Use a dictionary to store key-value pairs

    def hash_function(self, key):
        # Simple hash function (you can implement more sophisticated ones)
        hash_value = hash(key) % len(self.table) if self.table else 0
        return hash_value
    
    def save_to_file(self, filename):
        save_data_to_file(self.to_dict(), filename)

    def load_from_file(self, filename):
        loaded_data = load_data_from_file(filename, dict)
        if loaded_data:
            self.table = loaded_data

    def to_dict(self):
        """
        Converts the HashTable into a standard Python dictionary.
        Handles special serialization for nested DoublyLinkedList objects.
        """
        result = {}
        for bucket in self.table.values():
            if bucket:
                for key, value in bucket:
                    # Convert DoublyLinkedList to list if present
                    if isinstance(value, dict) and 'ride_history' in value:
                        value = value.copy()  # Avoid modifying the original value
                        value['ride_history'] = value['ride_history'].to_list()
                    result[key] = value
        return result

    @classmethod
    def from_dict(cls, data_dict):
        """
        Creates a HashTable from a standard Python dictionary.
        Handles special deserialization for nested DoublyLinkedList objects.
        """
        new_table = cls()
        for key, value in data_dict.items():
            # Deserialize DoublyLinkedList if present
            if isinstance(value, dict) and 'ride_history' in value:
                value = value.copy()
                value['ride_history'] = DoublyLinkedList.from_list(value['ride_history'])
            new_table.insert(key, value)
        return new_table

    def insert(self, key, value):
        index = self.hash_function(key)
        if index not in self.table:
            self.table[index] = []
        self.table[index].append((key, value))  # Handle collisions by storing in list

    def get(self, key):
        index = self.hash_function(key)
        if index in self.table:
            for k, v in self.table[index]:
                if k == key:
                    return v
        return None

    def delete(self, key):
        index = self.hash_function(key)
        if index in self.table:
            for i, (k, v) in enumerate(self.table[index]):
                if k == key:
                    del self.table[index][i]
                    break

    def values(self):
        # Flatten the table and return all values
        return [value for bucket in self.table.values() for key, value in bucket]

    def items(self):
        # Flatten the table and return all key-value pairs
        return [(key, value) for bucket in self.table.values() for key, value in bucket]

class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, item):
        self.queue.append(item)

    def dequeue(self):
        if self.queue:
            return self.queue.pop(0)
        return None

    def is_empty(self):
        return len(self.queue) == 0

    def peek(self):
        if self.queue:
            return self.queue[0]
        return None
    
    def to_dict(self):
        """
        Converts the Queue into a dictionary for serialization.
        """
        return {"queue": self.queue}

    @classmethod
    def from_dict(cls, data):
        """
        Reconstructs a Queue from a dictionary.
        """
        new_queue = cls()
        new_queue.queue = data.get("queue", [])
        return new_queue

class PriorityQueue(MinHeap):
    def __init__(self):
        super().__init__()

    def push(self, priority, item):
        super().push((priority, item))

    def pop(self):
        return super().pop()[1] if self.heap else None

    def peek(self):
        return self.heap[0][1] if self.heap else None

    def to_dict(self):
        """
        Converts the PriorityQueue into a dictionary for serialization.
        """
        return {"heap": self.heap}

    @classmethod
    def from_dict(cls, data):
        """
        Reconstructs a PriorityQueue from a dictionary.
        """
        new_pq = cls()
        new_pq.heap = data.get("heap", [])
        return new_pq

class AVLTree:
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.value = value
            self.height = 1
            self.left = None
            self.right = None

    def __init__(self):
        self.root = None

    # Implement AVL Tree methods (insert, delete, rotate, balance) as needed

# Additional data structures can be added here if necessary for the project requirements.
from data_structures import HashTable, DoublyLinkedList
from save_load import save_data_to_file, load_data_from_file
import uuid
import time

class DriverManagement:
    def __init__(self):
        # Load drivers from file or initialize an empty HashTable
        self.drivers = load_data_from_file('drivers_data.json', HashTable)
        self.active_drivers = HashTable()  # Currently available drivers

    def register_driver(self, name, email, phone, password, vehicle_type, license_number):
        driver_id = str(uuid.uuid4())
        driver_data = {
            'id': driver_id,
            'name': name,
            'email': email,
            'phone': phone,
            'password': password,  # Should be hashed in real system
            'vehicle_type': vehicle_type,
            'license_number': license_number,
            'rating': 0.0,
            'total_ratings': 0,
            'current_location': None,
            'active_ride': None,
            'ride_history': DoublyLinkedList()
        }

        if self.get_driver_by_email(email):
            return False, "Email already registered"

        self.drivers.insert(driver_id, driver_data)
        # Save to file immediately
        self.drivers.save_to_file('drivers_data.json')
        return True, driver_id

    def login_driver(self, email, password):
        print("Debug: Drivers table contents:", self.drivers.table)  # Debug statement
        for bucket in self.drivers.table.values():
            print("Debug: Current bucket:", bucket)  # Debug statement
            if bucket:  # Ensure the bucket is not empty
                for driver_id, driver_data in bucket:  # Iterate through the list of key-value pairs
                    print("Debug: Checking driver_data:", driver_data)  # Debug statement
                    if isinstance(driver_data, dict) and driver_data.get('email') == email and driver_data.get('password') == password:
                        return True, driver_id
        return False, "Invalid credentials"

    def update_driver_location(self, driver_id, location):
        driver_data = self.drivers.get(driver_id)
        if driver_data:
            driver_data['current_location'] = location
            self.drivers.insert(driver_id, driver_data)
            # Save updated data
            self.drivers.save_to_file('drivers_data.json')
            return True
        return False
    

    def set_driver_availability(self, driver_id, available):
        driver_data = self.drivers.get(driver_id)
        if driver_data:
            driver_data['availability'] = available  # Add or update availability
            self.drivers.insert(driver_id, driver_data)
            self.drivers.save_to_file('drivers_data.json')  # Save changes
        if available:
            self.active_drivers.insert(driver_id, driver_data)
        else:
            self.active_drivers.delete(driver_id)
            return True
        return False

    def get_driver_by_email(self, email):
        # Check if any driver has the given email
        for driver_data_list in self.drivers.table:
            if driver_data_list:  # Ensure there is data in this bucket
                for _, driver in driver_data_list:
                    if driver['email'] == email:
                        return driver
        return None

    def get_available_drivers(self):
        return [driver for driver in self.drivers.values() if driver.get('availability')]


    def get_driver_by_id(self, driver_id):
        return self.drivers.get(driver_id)
    
    @staticmethod
    def view_ride_requests(driver_id):
        ride_requests = load_data_from_file('ride_requests.json', list) or []
        
        if not ride_requests:
            print("No ride requests available.")
            return

        print("\n--- Ride Requests ---")
        for idx, request in enumerate(ride_requests, start=1):
            print(f"{idx}. Pickup: {request['pickup_location']}, Dropoff: {request['dropoff_location']}, User ID: {request['user_id']}")

        try:
            choice = int(input("Enter the number of the ride to accept: ")) - 1
            if 0 <= choice < len(ride_requests):
                selected_request = ride_requests.pop(choice)
                
                # Move to active rides
                active_rides = load_data_from_file('active_rides.json', list) or []
                active_rides.append({
                    "id": selected_request["id"],
                    "user_id": selected_request["user_id"],
                    "driver_id": driver_id,
                    "pickup_location": selected_request["pickup_location"],
                    "dropoff_location": selected_request["dropoff_location"],
                    "status": "ongoing",
                    "start_time": time.time()
                })

                # Save updated files
                save_data_to_file(ride_requests, 'ride_requests.json')
                save_data_to_file(active_rides, 'active_rides.json')
                print("Ride accepted successfully!")
            else:
                print("Invalid selection.")
        except ValueError:
            print("Invalid input. Please enter a valid number.")from data_structures import PriorityQueue
from save_load import save_data_to_file, load_data_from_file
import time
import uuid

class EmergencyHandler:
    def __init__(self, ride_request, location_service, driver_management, file_path='emergency_requests.json'):
        """
        Initializes EmergencyHandler and loads emergency requests from the specified file.
        """
        self.ride_request = ride_request
        self.location_service = location_service
        self.driver_mgmt = driver_management
        self.file_path = file_path
        self.emergency_requests = load_data_from_file(self.file_path, PriorityQueue)

    def add_emergency_request(self, user_id, pickup_location, dropoff_location):
        """
        Adds an emergency ride request to the queue with the highest priority.
        Simulates forwarding the request to a 911-like service.
        """
        request = {
            'id': str(uuid.uuid4()),
            'user_id': user_id,
            'pickup_location': pickup_location,
            'dropoff_location': dropoff_location,
            'timestamp': time.time(),
        }
        print(f"Emergency request forwarded to 911 service: {request}")
        self.emergency_requests.push(1, request)  # Priority 1 for emergency requests
        # Save updated emergency requests to file
        save_data_to_file(self.emergency_requests, self.file_path)
        return True, request['id']

    def dispatch_emergency_ride(self):
        """
        Processes the emergency ride queue and dispatches the nearest available emergency vehicle.
        Simulates fetching emergency vehicle location data from a 911-like service.
        """
        if self.emergency_requests.is_empty():
            return False, "No emergency requests in the queue."

        request = self.emergency_requests.pop()
        # Save updated emergency requests to file
        save_data_to_file(self.emergency_requests, self.file_path)

        # Simulate receiving nearest vehicle location from 911 service
        print(f"Fetching nearest emergency vehicle for request: {request['id']}")
        driver = self._find_nearest_driver(request['pickup_location'])

        if driver:
            ride_id = self.ride_request._assign_ride(request, driver['id'])
            return True, f"Emergency ride dispatched. Ride ID: {ride_id}"

        return False, "No available emergency vehicles for dispatch."

    def _find_nearest_driver(self, pickup_location):
        """
        Finds the nearest available driver for the given pickup location.
        Simulates receiving driver data from 911.
        """
        available_drivers = self.driver_mgmt.get_available_drivers()
        print("Available drivers fetched from 911 system.")
        nearest_driver = None
        min_distance = float('inf')

        for driver in available_drivers:
            if driver['current_location']:
                distance = self.location_service.get_shortest_path_distance(pickup_location, driver['current_location'])
                if distance < min_distance:
                    min_distance = distance
                    nearest_driver = driver

        return nearest_driver
import threading

file_lock = threading.Lock()  # Global lock for file operations
# friend_management.py
from data_structures import HashTable
from save_load import save_data_to_file, load_data_from_file

class FriendManagement:
    def __init__(self, user_management, file_path='friend_data.json'):
        self.user_mgmt = user_management
        self.friend_requests = HashTable()  # Store pending friend requests
        self.friends_list = HashTable()     # Store accepted friends
        self.user_mgmt = user_management
        self.file_path = file_path
        data = load_data_from_file(self.file_path, {'friend_requests': HashTable, 'friends_list': HashTable})
        self.friend_requests = data.get('friend_requests', HashTable())
        self.friends_list = data.get('friends_list', HashTable())

        data = load_data_from_file(self.file_path, dict) or {}
        self.friend_requests = HashTable.from_dict(data.get('friend_requests', {}))
        self.friends_list = HashTable.from_dict(data.get('friends_list', {}))

    def save_to_file(self):
        data = {
            'friend_requests': self.friend_requests.to_dict(),
            'friends_list': self.friends_list.to_dict()
        }
        save_data_to_file(data, self.file_path)

    def display_all_users(self):
        """Display all users with numbers for selection."""
        users = []
        for bucket in self.user_mgmt.users.table.values():
            if bucket:
                for user_id, user_data in bucket:
                    users.append((user_id, user_data))
        
        print("\n--- Available Users ---")
        for idx, (user_id, user_data) in enumerate(users, 1):
            print(f"{idx}. {user_data['name']} ({user_data['email']})")
        return users

    def send_friend_request(self, from_user_id, to_user_idx, users_list):
        """Send a friend request to selected user."""
        if to_user_idx < 1 or to_user_idx > len(users_list):
            return False, "Invalid user selection"
            
        to_user_id = users_list[to_user_idx - 1][0]
        
        if to_user_id == from_user_id:
            return False, "Cannot send friend request to yourself"
            
        # Check if already friends
        if self.are_friends(from_user_id, to_user_id):
            return False, "Already friends with this user"
            
        # Check if request already pending
        pending_requests = self.friend_requests.get(to_user_id) or []
        if from_user_id in pending_requests:
            return False, "Friend request already pending"
            
        # Store the friend request
        if not self.friend_requests.get(to_user_id):
            self.friend_requests.insert(to_user_id, [])
        pending_requests = self.friend_requests.get(to_user_id)
        pending_requests.append(from_user_id)
        self.friend_requests.insert(to_user_id, pending_requests)
        
        return True, "Friend request sent successfully"

    def get_pending_requests(self, user_id):
        """Get list of pending friend requests for a user."""
        requests = self.friend_requests.get(user_id) or []
        pending_users = []
        
        for from_user_id in requests:
            user_data = self.user_mgmt.get_user_by_id(from_user_id)
            if user_data:
                pending_users.append((from_user_id, user_data))
                
        return pending_users

    def accept_friend_request(self, user_id, from_user_idx, pending_requests):
        """Accept a friend request."""
        if from_user_idx < 1 or from_user_idx > len(pending_requests):
            return False, "Invalid selection"
            
        from_user_id = pending_requests[from_user_idx - 1][0]
        
        # Add to friends list for both users
        if not self.friends_list.get(user_id):
            self.friends_list.insert(user_id, [])
        if not self.friends_list.get(from_user_id):
            self.friends_list.insert(from_user_id, [])
            
        user_friends = self.friends_list.get(user_id)
        from_user_friends = self.friends_list.get(from_user_id)
        
        user_friends.append(from_user_id)
        from_user_friends.append(user_id)
        
        self.friends_list.insert(user_id, user_friends)
        self.friends_list.insert(from_user_id, from_user_friends)
        
        # Remove from pending requests
        pending_requests = self.friend_requests.get(user_id)
        pending_requests.remove(from_user_id)
        self.friend_requests.insert(user_id, pending_requests)
        
        return True, "Friend request accepted"

    def are_friends(self, user_id1, user_id2):
        """Check if two users are friends."""
        user1_friends = self.friends_list.get(user_id1) or []
        return user_id2 in user1_friends

    def get_friends_list(self, user_id):
        """Get list of friends for a user."""
        friends = self.friends_list.get(user_id) or []
        friend_users = []
        
        for friend_id in friends:
            user_data = self.user_mgmt.get_user_by_id(friend_id)
            if user_data:
                friend_users.append((friend_id, user_data))
                
        return friend_usersfrom data_structures import Graph
from map_data import IslamabadMap, LOCATIONS, DISTANCES
from save_load import save_data_to_file, load_data_from_file

class LocationService:
    def __init__(self, map_data, file_path='location_service.json'):
        self.map_data = map_data  # Store map_data as instance variable
        self.file_path = file_path
        self.graph = load_data_from_file(self.file_path, Graph)
        if not self.graph:
            self.graph = Graph()
            self._initialize_map(map_data)
            save_data_to_file(self.graph, self.file_path)

    def _initialize_map(self, map_data):
        """
        Initializes the graph with locations and distances from the map data.
        Returns the initialized graph.
        """
        # Create a new graph instance
        graph = Graph()

        # Add all locations as nodes
        locations = map_data.get_all_locations()
        for location in locations:
            graph.add_node(location)

        # Add all distances as edges
        for (start, end), distance in DISTANCES.items():
            graph.add_edge(start, end, distance)
            # Add reverse direction since roads are typically bidirectional
            graph.add_edge(end, start, distance)
        
        return graph

    def get_shortest_path(self, start, end):
        """Get the shortest path and its distance between two locations."""
        if not self.is_valid_location(start) or not self.is_valid_location(end):
            return None, "Invalid locations provided."
        
        try:
            distances, previous_nodes = self.graph.dijkstra_with_path(start)
            if distances[end] == float('inf'):
                return None, "No path exists between the specified locations."
            
            # Reconstruct path
            path = []
            current = end
            while current:
                path.insert(0, current)
                current = previous_nodes.get(current)
                
            return path, distances[end]
        except Exception as e:
            return None, f"Error calculating path: {str(e)}"

    def get_nearby_locations(self, location, max_distance):
        """Gets all locations within a specified distance from the given location."""
        if not self.is_valid_location(location):
            return []
        
        try:
            distances, _ = self.graph.dijkstra(location)
            return [loc for loc, dist in distances.items() if 0 < dist <= max_distance]
        except Exception:
            return []

    def get_distance_between(self, start, end):
        """Returns the shortest path distance between two locations."""
        if not self.is_valid_location(start) or not self.is_valid_location(end):
            return None
            
        try:
            distances, _ = self.graph.dijkstra(start)
            distance = distances.get(end)
            return None if distance == float('inf') else distance
        except Exception:
            return None

    def is_valid_location(self, location):
        """Checks if a location exists in the map."""
        return location in self.graph.nodes

    def save(self):
        """Save the current state of the graph."""
        save_data_to_file(self.graph, self.file_path)#main.py
import threading
import networkx as nx
import matplotlib.pyplot as plt
from user_management import UserManagement
from driver_management import DriverManagement
from friend_management import FriendManagement
from ride_request import RideRequest
from location_service import LocationService
from emergency_handler import EmergencyHandler
from social_rideshare import SocialRideshare
from pricing import Pricing
from ride_history import RideHistory
from map_data import IslamabadMap
from data_structures import Graph
from data_structures import HashTable
from polling import poll_file, reload_drivers, reload_users

from dashboards import Dashboards
from map_visualization import visualize_map, visualize_ride_path


def initialize_system():
    """Initialize all system components in the correct order"""
    # Initialize base services first
    map_data = IslamabadMap()
    location_service = LocationService(map_data)
    pricing = Pricing()
    
    # Initialize management systems
    user_mgmt = UserManagement()
    driver_mgmt = DriverManagement()
    friend_mgmt = FriendManagement(user_mgmt)
    ride_history = RideHistory()
    
    # Initialize ride request system with all required dependencies
    ride_request = RideRequest(
        user_management=user_mgmt,
        driver_management=driver_mgmt,
        location_service=location_service,
        pricing=pricing
    )
    
    # Initialize additional services that depend on core components
    emergency_handler = EmergencyHandler(ride_request, location_service, driver_mgmt)
    social_rideshare = SocialRideshare()
    
    # Initialize dashboard last as it depends on all other components
    dashboards = Dashboards(user_mgmt, driver_mgmt, ride_request, location_service, pricing, ride_history, emergency_handler, friend_mgmt)
    
    return {
        'user_mgmt': user_mgmt,
        'driver_mgmt': driver_mgmt,
        'location_service': location_service,
        'pricing': pricing,
        'ride_request': ride_request,
        'emergency_handler': emergency_handler,
        'social_rideshare': social_rideshare,
        'dashboards': dashboards,
        'ride_history': ride_history
    }

def main():

    # Initialize the system
    system = initialize_system()
    Dashboards = system['dashboards']

    # Start polling threads for user and driver data
    user_poll_thread = threading.Thread(target=poll_file, args=('users_data.json', reload_users), daemon=True)
    driver_poll_thread = threading.Thread(target=poll_file, args=('drivers_data.json', reload_drivers), daemon=True)
    user_poll_thread.start()
    driver_poll_thread.start()

    while True:
        try:
            print("\n--- Main Menu ---")
            print("1. User Login")
            print("2. Driver Login")
            print("3. User Signup")
            print("4. Driver Signup")
            print("5. Exit")
            
            choice = input("Enter your choice: ")
            
            if choice == '1':
                Dashboards.run_user_login()
            elif choice == '2':
                Dashboards.run_driver_login()
            elif choice == '3':
                Dashboards.run_user_signup()
            elif choice == '4':
                Dashboards.run_driver_signup()
            elif choice == '5':
                print("Exiting...")
                break
            else:
                print("Invalid choice. Please try again.")
        except KeyboardInterrupt:
            print("\nProgram interrupted. Exiting gracefully.")
            break

if __name__ == "__main__":
    main()
#map_data.py
from data_structures import Graph
from save_load import save_data_to_file, load_data_from_file

# Dictionary of locations with their coordinates (x, y)
LOCATIONS = {
    # Sectors
    'F-6 Markaz': (0, 0),
    'F-7 Markaz': (2, 1),
    'G-9 Markaz': (-2, 3),
    'I-8 Markaz': (-4, 5),
    'E-11 Markaz': (-3, -2),
    'F-10 Markaz': (1, 3),
    'G-11 Markaz': (-1, 4),
    'F-17': (5, 7),
    'E-11': (-3, -3),
    'G-10': (0, 4),
    'D-12': (-5, -1),
    'F-11': (2, 4),
    'G-6': (-1, 1),
    
    # Universities
    'IIUI': (-6, 6),
    'Air University': (3, 5),
    'FAST University': (1, 2),
    'COMSATS': (4, 3),
    'NUST': (-2, 6),
    
    # Landmarks
    'Faisal Mosque': (0, 5),
    'Shakarparian': (3, -1),
    'Pakistan Monument': (2, -2),
    'Daman-e-Koh': (1, 6),
    'Centaurus Mall': (2, 0),
    'Serena Hotel': (1, 1)
}

# Dictionary of direct distances between connected locations
DISTANCES = {
    # Major connections between sectors
    ('F-6 Markaz', 'F-7 Markaz'): 3,
    ('F-7 Markaz', 'F-10 Markaz'): 4,
    ('F-10 Markaz', 'F-11'): 2,
    ('G-9 Markaz', 'G-10'): 2,
    ('G-10', 'G-11 Markaz'): 3,
    ('E-11 Markaz', 'E-11'): 1,
    ('I-8 Markaz', 'G-9 Markaz'): 5,
    
    # Connections to universities
    ('F-7 Markaz', 'FAST University'): 3,
    ('G-11 Markaz', 'NUST'): 4,
    ('F-10 Markaz', 'Air University'): 4,
    ('G-9 Markaz', 'COMSATS'): 6,
    ('E-11', 'IIUI'): 8,
    
    # Connections to landmarks
    ('F-7 Markaz', 'Centaurus Mall'): 2,
    ('F-6 Markaz', 'Serena Hotel'): 2,
    ('G-10', 'Faisal Mosque'): 3,
    ('F-11', 'Daman-e-Koh'): 4,
    ('F-7 Markaz', 'Pakistan Monument'): 4,
    ('F-6 Markaz', 'Shakarparian'): 5,
    
    # Additional strategic connections
    ('G-6', 'F-6 Markaz'): 2,
    ('G-6', 'G-9 Markaz'): 4,
    ('F-10 Markaz', 'G-10'): 2,
    ('F-11', 'E-11'): 5,
    ('D-12', 'E-11'): 3,
    ('F-17', 'Air University'): 4
}

class IslamabadMap:
    def __init__(self, file_path='map_data.json'):
        self.file_path = file_path
        self.graph = load_data_from_file(self.file_path, Graph) or self._initialize_map()

    
    def _initialize_map(self):
        for location in LOCATIONS:
            self.graph.add_node(location)
        for (start, end), distance in DISTANCES.items():
            self.graph.add_edge(start, end, distance)
        print("Initialized Graph Nodes:", self.graph.nodes)
        print("Initialized Graph Edges:", [(start, end) for start, neighbors in self.graph.nodes.items() for end in neighbors])

    
    def get_location_coordinates(self, location):
        """Get the coordinates of a specific location."""
        return LOCATIONS.get(location)
    
    def get_direct_distance(self, start, end):
        """Get the direct distance between two locations if they're directly connected."""
        return DISTANCES.get((start, end)) or DISTANCES.get((end, start))
    
    def get_shortest_path_distance(self, start, end):
        if start not in self.nodes or end not in self.nodes:
            return None
        distances, _ = self.dijkstra(start)
        return distances.get(end, float('inf'))

    
    def get_nearby_locations(self, location, max_distance):
        """Get all locations within a specified distance of a given location."""
        if location not in LOCATIONS:
            return []
        distances = self.graph.dijkstra(location)
        return [loc for loc, dist in distances.items() if 0 < dist <= max_distance]
    
    def get_all_locations(self):
        """Return a list of all locations in the map."""
        return list(LOCATIONS.keys())
    
    def get_location_type(self, location):
        """Return the type of location (Sector, University, or Landmark)."""
        if location not in LOCATIONS:
            return None
        if 'University' in location or 'NUST' in location or 'IIUI' in location or 'COMSATS' in location:
            return 'University'
        if any(sector in location for sector in ['F-', 'G-', 'I-', 'E-', 'D-']):
            return 'Sector'
        return 'Landmark'
    

# Helper functions for the map
def is_valid_location(location):
    """Check if a location exists in the map."""
    return location in LOCATIONS

def get_distance_matrix():
    """Generate a complete distance matrix between all locations."""
    map_instance = IslamabadMap()
    locations = list(LOCATIONS.keys())
    matrix = {}
    
    for start in locations:
        matrix[start] = {}
        distances = map_instance.graph.dijkstra(start)
        for end in locations:
            matrix[start][end] = distances[end]
    
    return matrix
#map_visualization.py
import networkx as nx
import matplotlib.pyplot as plt
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))


def visualize_map(location_service):
    G = nx.Graph()
    for node in location_service.graph.nodes:
        G.add_node(node)
    for start, neighbors in location_service.graph.nodes.items():
        for end, distance in neighbors.items():
            G.add_edge(start, end, weight=distance)

    pos = nx.spring_layout(G)
    plt.figure(figsize=(10, 8))
    plt.gca().set_facecolor('black')

    nx.draw(
        G, pos,
        with_labels=True,
        node_color='lightgrey',
        edge_color='red',
        font_color='white',
        node_size=2000,
        font_size=10
    )

    labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_color='white')

    plt.title("Islamabad Ride-Hailing Map", color='white', fontsize=14)
    plt.show()

def visualize_ride_path(location_service, start, end):
    distance, path = location_service.graph.get_shortest_path(start, end)
    if path:
        G = nx.Graph()
        for node in location_service.graph.nodes:
            G.add_node(node)
        for start_node, neighbors in location_service.graph.nodes.items():
            for end_node, distance in neighbors.items():
                G.add_edge(start_node, end_node, weight=distance)

        pos = nx.spring_layout(G)
        nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=2000, font_size=10)

        path_edges = [(path[i], path[i + 1]) for i in range(len(path) - 1)]
        nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='red', width=2)

        labels = nx.get_edge_attributes(G, 'weight')
        nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

        plt.title(f"Ride Path from {start} to {end} (Distance: {distance})")
        plt.show()
    else:
        print("No path found between the selected locations.")
import os
import time
import sys
import hashlib
import threading
from data_structures import HashTable
from file_lock import file_lock
from user_management import UserManagement
from driver_management import DriverManagement


sys.path.append(os.path.dirname(os.path.abspath(__file__)))

user_mgmt = UserManagement()
driver_mgmt = DriverManagement()
hash_table = HashTable()

def calculate_file_hash(filename):
    """Calculate the hash of a file."""
    try:
        with open(filename, 'rb') as f:
            file_content = f.read()
            return hashlib.sha256(file_content).hexdigest()
    except FileNotFoundError:
        return None

def poll_file(filename, callback, poll_interval=1):
    """
    Polls a file for changes and reloads it using a callback when modified.
    Uses a lock to synchronize file access.
    """
    last_hash = calculate_file_hash(filename)

    while True:
        time.sleep(poll_interval)  # Wait for the next poll cycle
        with file_lock:  # Lock the file during hash calculation
            current_hash = calculate_file_hash(filename)

        if current_hash != last_hash:
            print(f"File {filename} has been updated. Reloading...")
            with file_lock:  # Lock the file during reload
                callback(filename)
            last_hash = current_hash

def reload_users(filename):
    """
    Reloads the user data from the specified file and updates the user management system.
    """
    try:
        user_mgmt.users.load_from_file(filename)
        print(f"User data reloaded from {filename}")
    except FileNotFoundError:
        print(f"Error: {filename} not found.")
    except Exception as e:
        print(f"An error occurred while reloading users: {e}")

def reload_drivers(filename):
    """
    Reloads the driver data from the specified file and updates the driver management system.
    """
    try:
        driver_mgmt.drivers.load_from_file(filename)
        print(f"Driver data reloaded from {filename}")
    except FileNotFoundError:
        print(f"Error: {filename} not found.")
    except Exception as e:
        print(f"An error occurred while reloading drivers: {e}")# pricing.py
from save_load import save_data_to_file, load_data_from_file

class Pricing:
    def __init__(self, base_rate=10, per_km_rate=5, rideshare_discount=0.2, surge_multiplier=1.0, file_path='pricing.json'):
        self.file_path = file_path
        data = load_data_from_file(self.file_path, dict) or {}
        self.base_rate = data.get('base_rate', base_rate)
        self.per_km_rate = data.get('per_km_rate', per_km_rate)
        self.rideshare_discount = data.get('rideshare_discount', rideshare_discount)
        self.surge_multiplier = data.get('surge_multiplier', surge_multiplier)

    def save_to_file(self):
        data = {
            'base_rate': self.base_rate,
            'per_km_rate': self.per_km_rate,
            'rideshare_discount': self.rideshare_discount,
            'surge_multiplier': self.surge_multiplier,
        }
        save_data_to_file(data, self.file_path)

    
    def calculate_fare(self, distance, is_rideshare=False, is_peak_time=False):
        """
        Calculates the fare for a given distance, with options for ridesharing and peak time pricing.
        """
        fare = self.base_rate + (distance * self.per_km_rate)
        if is_rideshare:
            fare *= (1 - self.rideshare_discount)
        if is_peak_time:
            fare *= self.surge_multiplier
        return round(fare, 2)

    def split_fare(self, total_fare, num_passengers):
        """
        Splits the fare among rideshare participants.
        """
        if num_passengers <= 0:
            return total_fare
        return round(total_fare / num_passengers, 2)class RatingSystem:
    def __init__(self, driver_management):
        self.driver_mgmt = driver_management

    def post_ride_feedback(self, driver_id, ride_id, rating, feedback=""):
        if rating < 1 or rating > 5:
            return False, "Rating must be between 1 and 5"

        driver = self.driver_mgmt.get_driver_by_id(driver_id)
        if not driver:
            return False, "Driver not found"

        # Update driver's rating
        total_ratings = driver['total_ratings']
        current_rating = driver['rating']

        new_total = total_ratings + 1
        new_rating = ((current_rating * total_ratings) + rating) / new_total

        driver['rating'] = round(new_rating, 2)
        driver['total_ratings'] = new_total

        # Add feedback
        if 'feedback' not in driver:
            driver['feedback'] = []
        driver['feedback'].append({
            'ride_id': ride_id,
            'rating': rating,
            'feedback': feedback
        })

        # Save updated driver data
        self.driver_mgmt.drivers.insert(driver_id, driver)
        self.driver_mgmt.drivers.save_to_file('drivers_data.json')

        return True, "Feedback submitted successfully"
from data_structures import DoublyLinkedList
from save_load import save_data_to_file, load_data_from_file

class RideHistory:
    def __init__(self, file_path='ride_history.json'):
        """
        Initializes the RideHistory with data loaded from a file if it exists.
        """
        self.file_path = file_path
        self.ride_history = load_data_from_file(self.file_path, DoublyLinkedList)

    def add_ride(self, ride_data):
        """
        Adds a ride record to the user's ride history and saves the updated history to the file.
        """
        self.ride_history.append(ride_data)
        save_data_to_file(self.ride_history, self.file_path)

    def get_ride_history(self):
        """
        Returns the list of all past rides in chronological order.
        """
        history = []
        current = self.ride_history.head
        while current:
            history.append(current.data)
            current = current.next
        return history
from data_structures import PriorityQueue, Queue, HashTable
from save_load import save_data_to_file, load_data_from_file
from rating_system import RatingSystem
import time
import uuid

class RideRequest:
    def __init__(self, user_management, driver_management, location_service, pricing):  # Added missing dependencies
        self.user_mgmt = user_management
        self.driver_mgmt = driver_management
        self.location_service = location_service  # Added missing service
        self.pricing = pricing  # Added missing service
        self.rating_system = RatingSystem  # Store rating system instance
        self.normal_requests = load_data_from_file('normal_requests.json', Queue) or Queue()  # Added fallback
        self.emergency_requests = load_data_from_file('emergency_requests.json', PriorityQueue) or PriorityQueue()
        self.active_rides = load_data_from_file('active_rides.json', HashTable) or HashTable()

    '''def request_ride(self, user_id, pickup_location, dropoff_location, is_emergency=False):
        user = self.user_mgmt.get_user_by_id(user_id)
        print("User Data in request_ride:", user)
        if not user or user['active_ride']:
            print("User Data:", user)
            return False, "Invalid user or user already has active ride"
        


        # Calculate distance and price
        distance = self.location_service.graph.get_shortest_path_distance(pickup_location, dropoff_location)
        if distance is None:
            print("Pickup:", pickup_location, "Destination:", dropoff_location)
            print("Graph Nodes:", self.location_service.graph.nodes)
            print("Graph Edges:", self.location_service.graph.nodes)

            return False, "Could not calculate route"

        price = self.pricing.calculate_fare(distance)

        request = {
            'id': str(uuid.uuid4()),
            'user_id': user_id,
            'pickup_location': pickup_location,
            'dropoff_location': dropoff_location,
            'status': 'pending',
            'timestamp': time.time(),
            'distance': distance,
            'price': price
        }

        if is_emergency:
            self.emergency_requests.push(1, request)
            save_data_to_file(self.emergency_requests, 'emergency_requests.json')
        else:
            self.normal_requests.enqueue(request)
            print("Enqueued Request:", request)
            save_data_to_file(self.normal_requests, 'normal_requests.json')

        return True, request'''
    
    def request_ride(self, user_id, pickup_location, dropoff_location, is_emergency=False):
            user = self.user_mgmt.get_user_by_id(user_id)
            if not user or user['active_ride']:
                return False, "Invalid user or user already has active ride"
            
            # Force graph initialization if empty
            if not self.location_service.graph.nodes:
                print("Graph is empty. Reinitializing map...")
                self.location_service.graph = self.location_service._initialize_map()

            # Calculate distance and price
            distance = self.location_service.graph.get_shortest_path_distance(pickup_location, dropoff_location)
            if distance is None:
                return False, "Could not calculate route"

            price = self.pricing.calculate_fare(distance)
            request = {
                'id': str(uuid.uuid4()),
                'user_id': user_id,
                'pickup_location': pickup_location,
                'dropoff_location': dropoff_location,
                'status': 'pending',
                'timestamp': time.time(),
                'distance': distance,
                'price': price
            }

            if is_emergency:
                self.emergency_requests.push(distance, request)
                save_data_to_file(self.emergency_requests, 'emergency_requests.json')
            else:
                self.normal_requests.enqueue(request)
                save_data_to_file(self.normal_requests, 'normal_requests.json')

            # Synchronize with driver view
            self._sync_driver_requests()
            return True, request

    def _sync_driver_requests(self):
        """Sync ride requests to driver viewable file (ride_requests.json)."""
        save_data_to_file(self.normal_requests, 'ride_requests.json')


    '''def process_ride_requests(self):
        # Process emergency requests first
        while not self.emergency_requests.is_empty():
            request = self.emergency_requests.pop()
            save_data_to_file(self.emergency_requests, 'emergency_requests.json')
            driver = self._find_nearest_driver(request['pickup_location'])
            if driver:
                self._assign_ride(request, driver['id'])

        # Process normal requests
        while not self.normal_requests.is_empty():
            request = self.normal_requests.dequeue()
            save_data_to_file(self.normal_requests, 'normal_requests.json')
            driver = self._find_nearest_driver(request['pickup_location'])
            if driver:
                self._assign_ride(request, driver['id'])
            else:
                self.normal_requests.enqueue(request)
                save_data_to_file(self.normal_requests, 'normal_requests.json')'''
    
    def process_ride_requests(self):
        # Process emergency requests first
        while not self.emergency_requests.is_empty():
            priority, request = self.emergency_requests.pop()
            save_data_to_file(self.emergency_requests, 'emergency_requests.json')
            driver = self._find_nearest_driver(request['pickup_location'])
            if driver:
                self._assign_ride(request, driver['id'])

        # Process normal requests
        while not self.normal_requests.is_empty():
            request = self.normal_requests.dequeue()
            save_data_to_file(self.normal_requests, 'normal_requests.json')
            driver = self._find_nearest_driver(request['pickup_location'])
            if driver:
                self._assign_ride(request, driver['id'])
            else:
                self.normal_requests.enqueue(request)
                save_data_to_file(self.normal_requests, 'normal_requests.json')


    def _find_nearest_driver(self, pickup_location):
        available_drivers = self.driver_mgmt.get_available_drivers()
        nearest_driver = None
        min_distance = float('inf')

        for driver in available_drivers:
            if driver['current_location']:
                distance = self._calculate_distance(pickup_location, driver['current_location'])
                if distance < min_distance:
                    min_distance = distance
                    nearest_driver = driver

        return nearest_driver

    def _assign_ride(self, request, driver_id):
        ride_id = str(uuid.uuid4())
        ride_data = {
            'id': ride_id,
            'request': request,
            'driver_id': driver_id,
            'status': 'assigned',
            'start_time': time.time()
        }

        self.active_rides.insert(ride_id, ride_data)
        save_data_to_file(self.active_rides, 'active_rides.json')

        # Update user and driver status
        user = self.user_mgmt.get_user_by_id(request['user_id'])
        driver = self.driver_mgmt.get_driver_by_id(driver_id)

        user['active_ride'] = ride_id
        driver['active_ride'] = ride_id
        self.driver_mgmt.set_driver_availability(driver_id, False)

        return ride_id

    def complete_ride(self, ride_id):
        ride_data = self.active_rides.get(ride_id)
        if not ride_data:
            return False, "Ride not found"

        ride_data['status'] = 'completed'
        ride_data['end_time'] = time.time()
        ride_data['duration'] = ride_data['end_time'] - ride_data['start_time']

        user_id = ride_data['request']['user_id']
        driver_id = ride_data['driver_id']

        user = self.user_mgmt.get_user_by_id(user_id)
        driver = self.driver_mgmt.get_driver_by_id(driver_id)

        if user and driver:
            user['ride_history'].append(ride_data)
            driver['ride_history'].append(ride_data)

            user['active_ride'] = None
            driver['active_ride'] = None
            self.driver_mgmt.set_driver_availability(driver_id, True)

            self.active_rides.delete(ride_id)
            save_data_to_file(self.active_rides, 'active_rides.json')

            # Prompt for post-ride feedback
            print("\n--- Post-Ride Feedback ---")
            print(f"Ride ID: {ride_id}")
            print(f"Driver: {driver['name']} ({driver['vehicle_type']})")
            try:
                rating = float(input("Rate the driver (1-5): "))
                feedback = input("Leave any additional feedback (optional): ")
                success, message = RatingSystem.post_ride_feedback(driver_id, ride_id, rating, feedback)
                print(message)
            except ValueError:
                print("Invalid rating. Feedback skipped.")

            return True, "Ride completed successfully"
        return False, "Error updating user or driver profiles"

    def get_user_updates(self, user_id):
        user = self.user_mgmt.get_user_by_id(user_id)
        if not user or not user['active_ride']:
            return None

        ride_data = self.active_rides.get(user['active_ride'])
        if not ride_data:
            return None

        driver = self.driver_mgmt.get_driver_by_id(ride_data['driver_id'])
        if not driver:
            return None

        return {
            'type': 'ride_accepted',
            'ride_id': ride_data['id'],
            'driver': {
                'name': driver['name'],
                'phone': driver['phone'],
                'vehicle_type': driver['vehicle_type'],
                'current_location': driver['current_location']
            },
            'status': ride_data['status']
        }

    def get_driver_requests(self, current_location):
        if not self.normal_requests.queue:
            return []

        available_requests = []
        for request in self.normal_requests.queue:
            distance_to_pickup = self._calculate_distance(current_location, request['pickup_location'])
            ride_distance = self._calculate_distance(request['pickup_location'], request['dropoff_location'])
            fare = self._calculate_fare(ride_distance)

            request_data = {
                'id': request['id'],
                'pickup_location': request['pickup_location'],
                'dropoff_location': request['dropoff_location'],
                'distance': ride_distance,
                'distance_to_pickup': distance_to_pickup,
                'price': fare
            }
            available_requests.append(request_data)

        return available_requests

    def accept_ride(self, driver_id, request_id):
        request = None
        remaining_requests = []

        for req in self.normal_requests.queue:
            if req['id'] == request_id:
                request = req
            else:
                remaining_requests.append(req)

        if not request:
            return False, "Request no longer available"

        self.normal_requests.queue = remaining_requests
        save_data_to_file(self.normal_requests, 'normal_requests.json')

        ride_id = self._assign_ride(request, driver_id)
        return True, ride_id

    def _calculate_distance(self, location1, location2):
        return self.location_service.get_distance_between(location1, location2) or 0

    def _calculate_fare(self, distance):
        return self.pricing.calculate_fare(distance)
#save_load.py

import json
from file_lock import file_lock

def save_data_to_file(data, filename):
    """Save data to a file with thread-safe locking."""
    try:
        if hasattr(data, "to_dict"):
            data = data.to_dict()  # Use to_dict if the object supports it

    
        if hasattr(data, "to_list"):
            data = data.to_list()  # Convert to a list if the object supports it

        with file_lock:  # Lock the file during the save operation
            with open(filename, 'w') as f:
                json.dump(data, f, indent=4)
        print(f"Data successfully saved to {filename}")
    except Exception as e:
        print(f"Error saving to file {filename}: {e}")

def load_data_from_file(filename, data_type):
    """Load data from a file with thread-safe locking."""
    try:
        with file_lock:  # Lock the file during the load operation
            with open(filename, 'r') as f:
                data = json.load(f)

        if hasattr(data_type, "from_dict"):
            return data_type.from_dict(data)  # Use from_dict if the class supports it
        
        if hasattr(data_type, "from_list"):
            return data_type.from_list(data)  # Use from_list if the class supports it

        return data  # Return raw data for other types
    except json.JSONDecodeError:
        print(f"Error loading file {filename}: File is empty or contains invalid JSON. Reinitializing with default {data_type}.")
        default_data = data_type() if callable(data_type) else {}
        save_data_to_file(default_data, filename)
        return default_data
    except FileNotFoundError:
        print(f"{filename} not found. Creating a new file with default {data_type}.")
        default_data = data_type() if callable(data_type) else {}
        save_data_to_file(default_data, filename)
        return default_data
    except Exception as e:
        print(f"Unexpected error loading file {filename}: {e}")
        return None

from data_structures import Graph
from save_load import save_data_to_file, load_data_from_file

class SocialRideshare:
    def __init__(self, file_path='user_connections.json'):
        """
        Initializes the SocialRideshare with user connections loaded from a file if it exists.
        """
        self.file_path = file_path
        self.user_connections = load_data_from_file(self.file_path, Graph)  # Load the graph from file

    def add_connection(self, user1, user2):
        """
        Establishes a connection between two users for potential ridesharing and saves the updated graph.
        """
        self.user_connections.add_node(user1)
        self.user_connections.add_node(user2)
        self.user_connections.add_edge(user1, user2, 1)  # Edge weight represents connection strength
        save_data_to_file(self.user_connections, self.file_path)  # Save the graph to file

    def find_rideshare_partners(self, user, pickup_location, dropoff_location):
        """
        Finds potential rideshare partners based on user connections and route similarity.
        """
        potential_partners = self.user_connections.get_neighbors(user)
        matches = []

        for partner in potential_partners:
            # Here you can add logic to match routes based on similarity (e.g., same path, close destinations).
            matches.append(partner)

        return matches
from data_structures import HashTable, DoublyLinkedList
from save_load import save_data_to_file, load_data_from_file
import uuid

class UserManagement:
    def __init__(self):
        # Load users from file or initialize an empty HashTable
        self.users = load_data_from_file('users_data.json', HashTable)
        self.active_sessions = HashTable()  # Active sessions are temporary and not loaded

    def register_user(self, name, email, phone, password):
        user_id = str(uuid.uuid4())
        user_data = {
            'id': user_id,
            'name': name,
            'email': email,
            'phone': phone,
            'password': password,  # In real system, this should be hashed
            'ride_history': DoublyLinkedList(),
            'active_ride': None
        }

        if self.get_user_by_email(email):
            return False, "Email already registered"

        self.users.insert(user_id, user_data)

        # Save to file immediately
        self.users.save_to_file('users_data.json')
        return True, user_id

    def login_user(self, email, password):
        print("Debug: Users table contents:", self.users.table)  # Debug statement
        for bucket in self.users.table.values():
            print("Debug: Current bucket:", bucket)  # Debug statement
            if bucket:  # Ensure the bucket is not empty
                for key, user_data in bucket:
                    print("Debug: Checking user_data:", user_data)  # Debug statement
                    if isinstance(user_data, dict) and user_data.get('email') == email and user_data.get('password') == password:
                        session_id = str(uuid.uuid4())  # Generate a session ID
                        self.active_sessions.insert(session_id, user_data['id'])  # Map session ID to user ID
                        return True, session_id  # Return the session ID
        print("Active Sessions:", self.active_sessions.table)
        return False, "Invalid credentials"
   
    def get_user_by_id(self, user_id):
        # Check if the provided user_id is a session ID
        original_user_id = self.active_sessions.get(user_id)
        if original_user_id:
            return self.users.get(original_user_id)
        return None  # Return None if neither session ID nor original user ID is found


    def get_user_by_email(self, email):
        for user_data in self.users.values():  # Use values() to get all user data
            if user_data['email'] == email:
                return user_data
        return None

    def update_user_profile(self, user_id, updates):
        user_data = self.users.get(user_id)
        if user_data:
            user_data.update(updates)
            self.users.insert(user_id, user_data)
            # Save updated data
            self.users.save_to_file('users_data.json')
            return True
        return False
